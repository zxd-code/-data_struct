1.设计一个算法将两个字符串合并按字母排序：遍历一次统计各字符出现次数，直接按字母顺序输出，O(n)。
数据结构：
2.排序、查找、二叉树、图；
3.哈希和B树各自特点；
    哈希索引的优势：
    (1)等值查询。哈希索引具有绝对优势（前提是：没有大量重复键值，如果大量重复键值时，哈希索引的效率很低，因为存在所谓的哈希碰撞问题。）
        哈希索引不适用的场景：
        (1)不支持范围查询
        (2)不支持索引完成排序
        (3)不支持联合索引的最左前缀匹配规则
    B+树是一个平衡的多叉树,从根节点到每个叶子节点的高度差值不超过1,而且同层级的节点间有指针相互链接。


    如果是等值查询,那么哈希索引明显有绝对优势,因为只需要经过一次算法即可找到相应的键值,前提是键值都是唯一的;如果键值不是唯一的,就需要先找到该键所在位置,然后再根据链表往后扫描，直到找到相应的数据;
    如果是范围查询检索,这时候哈希索引就毫无用武之地了,因为原先是有序的键值,经过哈希算法后,有可能变成不连续的了,就没办法再利用索引完成范围查询检索;
    同理，哈希索引也没办法利用索引完成排序，以及like 'xxx%' 这样的部分模糊查询(这种部分模糊查询，其实本质上也是范围查询)
    哈希索引也不支持多列联合索引的最左匹配规则；
    B+树索引的关键字检索效率比较平均,不像B树那样波动幅度大,在有大量重复键值情况下,哈希索引的效率也是极低的,因为存在所谓的哈希碰撞问题。

4.链表归并排序；
5.大根堆的实现，快排（如何避免最糟糕的状态？），bitmap的运用;
6.hash(例如为什么一般hashtable的桶数会取一个素数？如何有效避免hash结果值的碰撞);
