
3. Linux中各种IO模型原理--select和epoll:
    (1) 阻塞IO : client等待server回复过程中会一直阻塞, 进程会一直阻塞,直到数据拷贝完成
        大部分接口是阻塞型的:系统调用(IO)不返回调用结果,并让线程一直阻塞,只有当该系统调用获得结果或者超市出错才返回.(多线程)
        对每一个客户端启一个线程或者进程:pthread_create() fork()
    (2) 非阻塞IO : 用户一直向内核询问是否准备好了数据; 非阻塞IO通过进程反复调用IO函数(多次系统调用,并马上返回);在数据拷贝的过程中,进程是阻塞的;
    (3) 多路复用IO : 事件驱动IO,select和epoll会不断轮询所负责的所有socket
        比阻塞IO并没有什么优越性;关键是能实现同时对多个IO端口进行监听;
    (4) 信号驱动IO:两次调用,两次返回
    (5) 异步IO模型 : 

    select : slelect的参数类型没有将文件描述符和事件绑定,它仅仅是一个文件描述符集合
        缺点 :  1. 单个进程可监视的fd数量被限制,即能监听端口的大小有限
                2. 对socket进行扫描时是线性扫描,即采用轮询的方法,效率较低
                3. 需要维护一个用来存放大量fd的数据结构,这样会使得用户空间和内核空间在传递该结构时复制开销大
    poll : poll本质上和select没有区别,它将用户传入的数组拷贝到内核空间,然后查询每个fd对应的设备状态;它没有最大连接数的限制,原因是它是基于链表来存储的
        缺点 :  1. 大量的fd的数组被整体复制于用户态和内核地址空间之间,而不管这样的复制是不是有意义
                2. poll还有一个特点是"水平触发",如果报告了fd后,没有被处理,那么下次poll时会再次报告该fd
    epoll : 它在内核中维护一个事件表 
        优点 :  1. 没有最大并发连接的限制,能打开的FD的上限远大于1024
                2. 效率提升,不是轮询的方式,不会随着FD数目的增加效率下降.只有活跃可用的FD才会调用callback函数
                3. 内存拷贝,利用mmap()文件映射内存加速与内核空间的消息传递;即epoll使用mmap减少复制开销

    比较 ： select和poll都是采用的轮训的方式,即每次调用都要扫描整个注册文件描述符集合,并将其中就绪的文件描述符返回给用户程序,因此他们检测就绪事件的时间复杂度是O(n).
            epoll_wait则不同,它采用回调的方式

2. 阻塞和非阻塞I/O区别；
    阻塞IO:在准备阶段即同步阻塞,应用进程调用I/O操作时阻塞,只有等待要操作的数据准备好,并复制到应用进程的缓冲区中才返回
    非阻塞IO:当应用进程要调用的I/O操作会导致该进程进入阻塞状态时,该I/O调用返回一个错误,一般情况下,应用进程需要利用轮询的方式
    阻塞和非阻塞是针对于进程在访问数据的时候,根据IO操作的就绪状态来采取的不同方式,说白了是一种读取或者写入操作函数的实现方式,阻塞方式下读取或者写入函数将一直等待,
        而非阻塞方式下,读取或者写入函数会立即返回一个状态值。

3. linux系统文件机制；
    Linux下把一切资源都看成是文件

4. 多进程同步方式；
    (1) 信号量: PV操作,P(s):将信号量值减1； V(s) : 将信息量值加1
    (2) 消息传递 : 消息传递的实际功能以一对原语的形式提供:send(destination,message) receive(source,message)
            一个进程以消息的形式给另一个指定的目标进程发送消息,进程通过执行receive原语接收消息，receive原语中指明发送消息的源进程和消息。

5. 使用过哪些进程间通讯机制,并详细说明(重点)；
    (1) PIPE : 一是半双工的通信,数据只能单向流动;二是只能在具有亲缘关系的进程间使用,进程的亲缘关系通常是指父子进程关系.
    (2) FIFO : 有名管道也是半双工的通信方式,但是它允许无亲缘关系进程间的通信
    (3) 信号 : 
    (4) 消息队列 : 就是一个消息的链表,是一系列保存在内核中消息的列表.用户进程可以向消息队列添加消息,也可以向消息队列读取消息.msgget,msgctl
    (5) 共享内存 : 共享内存允许两个或多个进程共享一个给定的存储区,这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中 mmap,shmget,shmdt
    (6) 信号量 : 是一个计数器,可以用来控制多个进程对共享资源的访问.它常作为一种锁机制,防止某进程正在访问共享资源时,其他进程也访问该资源
    (7) socket : 是一种进程间通信机制,与其他通信机制不同的是它可用于不同及其间的进程通信.
    
6. linux系统的各类异步机制；
    由触发机制来通知处理消息者,时间驱动: select epoll

7. 信号：列出常见的信号，信号怎么处理？
    SIGINT, SIGKILL, SIGTSTP, 
    处理 : 1.显示地忽略信号, 2. 执行与信号相关的缺省操作, 3.通过调用相应的信号处理函数捕获信号

8. i++是否原子操作？
    不是

9. exit() _exit()的区别？
    _exit()执行后会立即返回给内核;而exit()要先执行一些清除操作,然后将控制权交给内核
    exit()函数是在_exit()函数上的一个封装,它会调用_exit,并在调用之前先刷新流

10. 如何实现守护进程？
    是运行在后台的一种特殊进程.它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件.守护进程是一种很有用的进程.

11. linux的内存管理机制是什么？
     linux的内存管理采取的是分页存取机制,为了保证物理内存能得到充分的利用,内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中,而将经常使用的信息保留到物理内存

12. linux的任务调度机制是什么？
    作业调度策略 : 进程优先级,运行时间片,进程抢占
    (1) 先来线服务策略
    (2) 时间片轮转算法
    (3) 段作业优先调度算法
    (4) 优先级调度算法
    (5) 最高响应比优先调度算法

13. 系统如何将一个信号通知到进程？
    内核给进程发送信号,是在进程所在的进程表项的信号域设置对应的信号的位.
    进程检查信号的时机是:进程即将从内核态返回用户态时,如果进程睡眠了,要看睡眠能不能被中断,如果能被中断则唤醒。
    执行用户自定义的信号处理函数的方法很巧妙:把该函数的地址放在用户栈栈顶,进程从内核返回到用户态的时候,先弹出信号处理函数地址,于是就去执行信号处理函数了,然后再弹出
        才是返回进入内核时的状态.

14. 什么是死锁?如何避免死锁？
    死锁是指多个进程因竞争资源而造成的一种僵局
    产生原因 : a.系统资源的竞争 b.进程推进顺序的不当
    产生死锁的四个必要原因 : a.互斥条件 b.请求与保持 c.不可剥夺条件 d.循环等待条件

    死锁预防是设法至少破坏产生死锁的四个必要条件之一,严格的防止死锁的出现
    死锁避免则不那么严格的限制产生死锁的必要条件的存在,因为即使死锁的必要条件存在,也不一定发生死锁.死锁避免是在系统运行过程中注意避免死锁的最终发生.

15. 共享内存的使用实现原理；
    两个不同进程A/B共享内存的意思是,同一块物理内存被映射到进程A\B各自的进程地址空间
    别的管道,消息队列需要在用户态和内核态进行4次数据拷贝,共享内存只需要2次：一次从输入文件到共享内存区，另一次从共享内存区到输出文件
    共享内存可以通过mmap()映射普通文件（特殊情况下还可以采用匿名映射）机制实现

16. 多线程和多进程的区别(从cpu调度,上下文切换,数据共享,多核cup利用率,资源占用,等等各方面回答.哪些东西是一个线程私有的?答案中必须包含寄存器)；
    多线程:
        1. 高效的内存共享,数据共享
        2. 较轻的上下文切换开销,不用切换地址空间
        3. 创建销毁切换比较简单
    多进程:
        1. 强的容错性，不会一阻全阻，一个进程崩溃不会整个系统崩溃

                                           进程                                                线程
        数据共享.同步   :   数据是分开的:共享复杂，需要用IPC;同步简单           多线程共享进程数据：共享简单；同步复杂
        内存、CPU       :   用内存多，切换复杂，CPU利用率低                     占用内存少，切换简单，CPU利用率高
        创建销毁、切换  :   创建销毁、切换复杂，速度慢                          创建销毁、切换简单，速度快 
        编程调试        :   编程简单，调试简单                                  编程复杂，调试复杂
        可靠性          :   进程间不会相互影响                                  一个线程挂掉将导致整个进程挂掉
        分布式          :   适应于多核、多机分布 ；如果一台机器不够，扩展到多台机器比较简单         适应于多核分布

17. 标准库函数和系统调用的区别？
    在用户地址空间执行                  在内核地址空间执行
    它的运行时间属于“用户时间”          它的运行时间属于“系统”时间
    属于过程调用，调用开销较小          需要在用户空间和内核上下文环境间切换，开销较大
    典型的C函数库调用：system fprintf malloc    典型的系统调用：chdir fork write brk；

    系统调用是操作系统相关的,因此一般没有跨操作系统的可移植性。
    系统调用和库函数在本书中都以正常的C函数的形式出现
