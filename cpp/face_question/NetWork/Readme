1. netstat tcpdump ipcs ipcrm命令；
    netstat : 显示网络信息,端口信息
    tcpdump : 对网络上的数据包进行截获的包分析工具;tcpdump可以将网络中传送的数据包的"头"完全截获下来提供分析
    ipcs    : ipcs提供进程间通信方式的信息,包括共享内存,信号量,消息队列
        ipcs -a     是默认的输出信息,打印出当前系统中所有的进程间通信方式的信息
        ipcs -m     打印出使用共享内存进行进程间通信的信息
        ipcs -q     打印出使用消息队列进行进程间通信的信息
        ipcs -s     打印出使用信号进行进程间通信的信息
    ipcrm   : 移除一个消息对象,或者共享内存段,或者一个信号集.同时会将与ipc对象相关链的数据也一起移除.当然,只有超级管理员,或者ipc对象的创建者才有这项权利啦
        ipcrm -M shmkey     移除用shmkey创建的共享内存段
        ipcrm -m shmid      移除用shmid标识的共享内存段
        ipcrm -Q msgkey     移除用msqkey创建的消息队列
        ipcrm -q msqid      移除用msqid标识的消息队列
        ipcrm -S semkey     移除用semkey创建的信号
        ipcrm -s semid      移除用semid标识的信号
        
2. cpu 内存 硬盘 等等与系统性能调试相关的命令；
    iostat : 一般我们可以通过top,iostat,free,vmstat等命令来查看初步定位问题.其中iostat可以给我们提供丰富的IO状态数据。
    vmstat : 可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率,内存使用,虚拟内存交换情况,IO读写情况.
        相比top,我可以看到整个机器的CPU,内存,IO的使用情况,而不是单单看到各个进程的CPU使用率和内存使用率(使用场景不一样).
    top free ps aux 
    
3. 设置修改权限chmod;
    
4. tcp网络状态查看;
    netstat -aptn | awk '{print $6}' | sort | uniq -c | sort -rn

5. 各进程状态;
    运行态：进程占用CPU,并在CPU上运行.
    就绪态：进程已经具备运行条件,但是CPU还没有分配过来.
    阻塞态：进程因等待某件事发生而暂时不能运行.
    
6. 抓包tcpdump;

7. awk sed了解；
    awk : 用于文本处理的语言(取行,过滤),支持正则
        NR代表行数,$n取某一列,$NF最后一列
        NR==20,NR==30 从20行到30行
        FS竖着切,列的分隔符
        RS横着切,行的分隔符
        awk '{print NR,$0}' /etc/inittab 给文件内容加行号
        awk -F ":" '$5~/^s/{print $0}' /etc/passwd    以：为分隔符，打印第5列以s开头的一整行
    sed : Strem Editor(流编辑器)缩写,是操作,过滤和转换文本内容的强大工具.常用功能有增删改查,过滤,取行
        sed '2a 106,dandan,CSO' person.txt // 单行增加
        sed '2a 106,dandan,CSO\n107,bingbing,CCO' person.txt //多行增加
        sed -n '2p' person.txt // 按行查询

8. tcp与udp的区别;

9. udp调用connect有什么作用？
    TCP中调用connect会引起三次握手,client与server建立连结;UDP中调用connect内核仅仅把对端ip&port记录下来.
    普通的UDP发送两个报文内核做了如下:#1:建立连结#2:发送报文#3:断开连结#4:建立连结#5:发送报文#6:断开连结
    采用connect方式的UDP发送两个报文内核如下处理:#1:建立连结#2:发送报文#3:发送报文另外一点,每次发送报文内核都由可能要做路由查询.

10. tcp连接中时序图，状态图，必须非常非常熟练;
    
11. socket服务端的实现，select和epoll的区别(必问);
    epoll的出现比较晚了,epoll是linux独有的高效的IO复用的机制.先简单提一下poll和select,poll和select很相似,但是poll没有select的文件描述符的限制(默认1024),poll使用pollfd结构代替描述符fd。 
    epoll与poll的不同在于:poll每次返回整个文件描述符的数组,用户代码需要遍历数组找到哪些文件描述符上有IO事件.
                          epoll_wait返回的是活动fd的列表,比遍历的数组小的多.epoll使用的是一种注册回调的机制,epoll_ctl为每一个fd指定一个回调函数,当设备就绪的时候,会唤醒等待队列中的等候者                   并调用其回调函数,回调函数会把对应的fd加入到就绪队列,epoll _wait就负责查询这个就绪队列,同时epoll也没有文件描述符数目的限制.
    select和poll就相当于轮询,需要遍历整个的fd集合来确定IO就绪.而epoll只需要判断一下就绪链表是否为空就可以了.

12. epoll哪些触发模式，有啥区别？(详尽的解释水平触发和边缘触发的区别，以及边缘触发在编程中要做哪些更多的确认)；
    如果稍微有点电子方面经验的人,相信对水平触发和边沿触发的概念就比较了解了.如果是边缘触发模式,就是当状态变化的时候才通知,对应电子中的高低电平变化的上升沿和下降沿;而水平触发则是你等待的       状态到了,就一直通知.
    注意因为边沿触发在被监控的文件描述符上有可读写事件发生时,epoll_wait会通知处理程序去读写,但是它只会通知一次,如果没有把数据全部读写完,下次调用epoll_wait时并不会通知你.因此需要去确认缓       冲区中的数据读写完毕,例如在非阻塞模式下读取数据,使用循环.根据返回的error,EAGIN和EWOULDBLOCK来判断数据是否全部读取完毕.

13. 大规模连接上来，并发模型怎么设计?

14. tcp结束连接怎么握手，time_wait状态是什么,为什么会有time_wait状态？哪一方会有time_wait状态，如何避免?
    主动关闭方会有一个TIME_WAIT状态,也称为2MSL状态.主要是防止新建立的连接使用原来的socket,迟到的报文到达后被错误的接收.MSL(maximum Segment Lifetime)是任何报文段被丢弃在网络内的最长时间        .在2MSL时间内,本次连接的socket(客户IP和端口,服务器IP和端口)不能再被使用.迟到的报文会被丢弃.
    TIME_WAIT的另一个存在理由是可靠的实现TCP全双工连接的终止.假设最终的ACK丢失了,服务器需要重新发送一个FIN,客户必须能够重新发送ACK,不然它将响应以一个RST,这将被服务器解释为一个错误. 

16. time_wait状态占用资源（必须回答的详细）?
    大量的TCP的短连接引发的TIME_WAIT会占用很多资源，其默认等待时间比较保守。 
        - 可以通过修改操作系统设置例如tcp_fin_timeout减少TIME_WAIT时间； 
        - 设置tcp_tw_recycle=1开启socket的快速回收； 
        - 使用比较激进的socket的SO_LINGER选项，设置为0，取消关闭等待。 
        - 或者选择使用tcp_tw_reuse开启socket的重用。

17. tcp头多少字节？哪些字段?(必问)
    20字节
    源端口,目的端口,序号,确认号,窗口大小,校验和,紧急指针
    下面是6个标志比特位： 
    　　URG：紧急指针有效,用以通知另一端紧急数据已经放置在普通的数据流中,仅仅是通知而已,具体如何处理由接收端决定.注意后面16位的紧急指针是一个正的偏移量,通过与TCP首部序号字段相加,得出紧急数据最后一个字节的序号.但是没有办法指明紧急数据从数据流的何处开始.TCP通过连接传送的唯一信息时紧急方式已经开始,以及结束位置.接收方当前读取位置到紧急指针之间的数据会使应用程序处于紧急方式,通过紧急指针后,恢复正常方式. 
    　　ACK：确认序列号有效. 
    　　PSH：接收方应该尽快将这个报文段交给应用层,当TCP向服务器发送一个报文段时,不要因等待额外数据而使已提交的数据在缓存中滞留.TCP的一些算法实现会推迟数据的交付,例如等待缓冲区填满。 
    　　RST：重建连接。 
    　　SYN：同步序号用来发起一个连接,既三次握手的同步。 
    　　FIN：发送端完成发送任务,常见于连接断开,四次挥手。

18. 什么是滑动窗口?（必问）
    滑动窗口协议是应流量控制方法.该协议允许发送方在停止并等待确认前可以连续发送多个分组.加速数据的传输.发送方不必发送一个全窗口大小的数据.
    在发送缓存中的数据可分为4个部分:已发送并被确认的，既已经收到对端ACK的数据;已发送但是未被确认的数据;未发送到但对端允许发送的数据;以及最后不可发送的数据。 
    滑动窗口由接收方通告,限制发送方的发送速度.其主要有两个作用:一是提供TCP的可靠性,二是控制流量.TCP的首部中有相关的字段window,上面已经介绍过了。 
    注意ACK是期望收到的下一个字节的序号n,并表示接收方已经收到了前n-1个字节,假如接收端收到1-1024个字节,它会发送一个1025的确认号,如果接下来收到的是2049-3072,它是不会接着发送3073的ACK的，而是接着发送1025。 
    通过窗口大小m和发送方接收到的ACK序列号n可以确认还可以发送多少数据,假设发送到第x字节,既可发送和不可发送的交界.则可以发送的字节数位y=m-(x-n).通过调整窗口大小就可以做到流量的控制. 
    当数据被发送和确认时,滑动窗口的左边沿向右移动,窗口合拢.当接收端读取已经确认的数据并释放TCP缓存时,窗口的右边沿向右移动,窗口张开.

19. connect会阻塞，怎么解决?(必考必问，提示：设置非阻塞，返回之后用select检测状态)；
    通过设置TCP套接字为非阻塞,并调用connect,connect会立即返回一个EINPROGRESS错误,但是已经发起的TCP三路握手继续进行.然后接着使用select检测连接的成功或者失败. 
    使用select和非阻塞connect,当连接成功建立的时候,描述符变为可写.当建立连接遇到错误的时候,描述符变为既可读又可写.下一个问题会更多的讲到select的描述符问题。 
    使用非阻塞的connect有三个用途:
        可以把三路握手叠加在其他处理上,既完成connect的时间内执行其他工作.
        同时建立多个连接.
        使用select等待连接建立,可以设置时间限制.缩短connect的超时.

20. 如果select返回可读，结果只读到0字节，什么情况？
        读到0表示该连接的读半部关闭(接收了FIN的TCP连接)。 
    　　对于select函数返回套接字就绪的情况。 
        　　可读： 
            　　1. 该套接字接收缓冲区的数据大于等于接收缓冲区低水位标记的当前大小.对此套接字执行读操作将不阻塞并返回一个>0的值,使用SO_REVLOWAT套接字选项设置低水位标记,默认为1。 
            　　2. 该连接读半部关闭,对此套接字读将不阻塞并返回0.（EOF） 
            　　3. 其上有一个错误待处理,对此套接字读不阻塞返回-1,并把errno设置成确切的错误条件.
            　　4. 该套接字是一个监听套接字并已完成的连接数不为0。

        　　可写： 
            　  1. 发送缓冲区可用空间字节数大于等于低水位标记,且改套接字已连接,或不需要连接UDP.写操作不阻塞返回正值,默认标记2048
            　　2. 该连接写半部关闭,写操作将产生SIGPIPE信号. 
            　　3. 使用非阻塞connect套接字连接已建立,或者已失败.
            　　4. 其上有一个错误待处理。同读。

21. keepalive 是什么东东？如何使用？

22. 列举你所知道的tcp选项，并说明其作用。
    kind表示类型，len为总长度。常见选项7种。 
    　　kind0：选项表结束。表示首部无更多消息。 
    　　kind1：无操作，用来填充字段为4字节的倍数。 
    　　kind2：MSS最大报文长度。 
    　　kind3：窗口扩大因子。窗口大小为原始的N*（1<<移位数）。 
    　　kind4：SACK，正常某个报文段丢失后会将其后所有报文重传，设置SACK后只重传丢失部分。 
    　　kind5：SACK具体部分，发送端据此重传。左边沿为不连续块的第一个数据序号，右边沿为最后一个不连续块数据序号的下一个序号。 
    　　kind8：时间戳。经常打log的应该都了解。

23. socket什么情况下可读？
    下列四个条件中的任何一个满足时,socket准备好读: 
    1.socket接收缓冲区中已经接收的数据的字节数大于等于socket接收缓冲区低潮限度的当前值;对这样的socket的读操作不会阻塞,并返回一个大于0的值(即:准备好读入的数据的字节数).我们可以用socket选项SO_RCVLOWAT来设置此低潮限度,对于TCP和UDPsocket,其缺省值为1; 
    2.连接的读这一半关闭(即:接收到对方发过来的FIN的TCP连接).对于这样的socket的读操作将不阻塞,并且返回0(即:文件结束符,FIN包体长度为0字节); 
    3.socket是一个用于监听的socket,并且已经完成的连接数为非0.这样的soocket处于可读状态,是因为socket收到了对方的connect请求,执行了三次握手的第一步:对方发送SYN请求过来,使监听socket处于可读状态;正常情况下,这样的socket上的accept操作不会阻塞; 
    4.有一个socket有异常错误条件待处理.对于这样的socket的读操作将不会阻塞,并且返回一个错误(-1),errno则设置成明确的错误条件.这些待处理的错误也可通过指定socket选项SO_ERROR调用getsockopt来取得并清除; 

    下列三个条件中的任何一个满足时,socket准备好写 : 
    1.socket发送缓冲区中的可用空间字节数大于等于socket发送缓冲区低潮限度的当前值,且(i):socket已连接(TCP socket),或者(ii):socket不要求连接(如:UDP socket).这意味着,如果我们将这样的socket设置为非阻塞模式,写操作将不会阻塞,并且返回一个正值(如:由传输层接收的字节数).我们可以用socket选项SO_SNDLOWAT来设置此低潮限度,对于TCP和UDP socket,其缺省值一般是2048Bytes; 
    2.连接的写这一半关闭.对于这样的socket的的写操作将产生信号SIGPIPE; 
    3.有一个socket异常错误条件待处理.对于这样的socket的写操作将不会阻塞并且返回一个错误(-1),errno则设置成明确的错误条件.这些待处理的错误也可以通过指定socket选项SO_ERROR调用getsockopt函数来取得并清除;
