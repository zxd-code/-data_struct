1.析构函数原理以及步骤；
    (1)首先执行函数体,然后再销毁成员,并且成员按照初始化的逆序进行销毁
    (2)虚析构函数是为了避免内存泄露,虚析构函数使得在删除指向子类对象的基类指针时可以调用子类的析构函数达到释放子类中堆内存的目的,而防止内存泄露的. 

2.类对象的内存存储形式；
    (1) 内存中的5大区域
         栈             ---局部变量,当局部变量的作用域被执行完毕之后,这个局部变量就会被系统立即回收
         堆             ---程序猿手动申请的字节空间,Malloc calloc realloc
         BBS段          ---未被初始化的全局变量和静态变量,一般初始化就回收,并转存到数据段中
         数据段(常量区) ---已经被初始化的全局静态变量常量数据,知道程序结束的时候才会被回收
         代码段         ---存储代码,存储程序的代码
    (2) 内存对齐部分

3. STL各种容器的特点和实现方式；
    (1) 6大组件 : 容器,算法,适配器,仿函数,迭代器
    (2) 容器分析:
        vector      --- 是动态数组,支持随机访问,有连续的内存空间.
                在push_back的过程中,若发现分配的内存空间不足,则重新分配一段连续的内存空间,其大小是现在连续空间的2倍.再将原先空间中的元素复制到新的空间中,性能消耗比较大,尤其是当元素是非                内部数据时(非内部数据往往构造及拷贝构造函数相当复杂).vector的另一个常见的问题就是clear操作,clear函数只是把vector的size清为零,但vector中的元素在内存中并没有消除,所以在使用               vector的过程中会发现内存消耗会越来越多,导致内存泄露,现在经常用的方法是swap函数来进行解决:利用swap函数，和临时对象交换，使V对象的内存为临时对象的内存，而临时对象的内存为V                对象的内存。交换以后，临时对象消失，释放内存。
        deque       --- 支持双端插入数据
                deque的内存空间分布是小片的连续,小片间用链表相连,实际上内部有一个map的指针.deque空间的重新分配要比vector快,重新分配空间后,原有的元素是不需要拷贝的
        list        --- 双向链表
                内存空间是可以不连续的,通过指针来进行数据的访问.可以很好地支持任意地方的插入和删除,只需移动相应的指针即可

4. c++进程内存空间分布（注意栈从高道低分配，堆从低到高分配）；
    跟2 堆区从低地址到高地址,栈区从高地址到底地址(相对而生)

5. 虚函数以及虚函数的作用(简单来说是多态,本质是为了封装)(哪些是编译时确定,哪些是运行时确定)；
    虚函数表是在编译时确定的,虚函数指针是在运行时确定的

6. makefile编译；
    target:生成target所需要的目标或文件
        要执行的命令

7. gdb调试；
    r：运行调试
    n：下一步
    b：添加断点
    p：打印值
    s：单步调试进入子函数
    l：查看源码

8. 如何定位内存泄露；
    查看进程消耗CPU和资源的信息free-m top

9. 动态链接和静态链接的区别；
    静态链接lib:程序在编译时将库文件加载进exe文件,导致目标文件大
    动态链接dll:程序在执行的时候向操作系统请求链接,程序在首次加载时可能耗时,但是目标文件体积不是很大
    
10. 32位系统一个进程最多多少堆内存；
    4G

11. 写一个c程序辨别系统是64位 or 32位；
    std::cout << sizeof(p) << std::endl;

12. 写一个c程序辨别系统是大端 or 小端字节序；
    typedef union{
        unsigned short value;
        unsigned char bytes[2];
    }Test;

    int main(void)
    {
        Test test_value;
        test_value.value = 0x1234;

        if(test_value.bytes[0] == 0x12 && test_value.bytes[1] == 0x34)
            printf("big ending");
        else if(test_value.bytes[0] == 0x34 && test_value.bytes[1] == 0x12)
            printf("little ending");
        else
            printf("use test_value error");
        return 0;
    }

13. 宏定义和展开；
    只替换不计算

14. 位操作；
    
15. 内存分配；

16. 哪些库函数属于高危函数？为什么？（strcpy等等）；
    边界类函数
    strcpy, strcat --> strncpy strncat

17. 一个String类的完整实现必须很快速写出来（注意：赋值构造，operator=是关键）;
    String & String::operator=(String &other){
        if(this == &other) //若对象与other是同一个对象，直接返回本{
            return *this
        }
        delete [] m_str; //否则，先释放当前对象堆内存

        m_str = new char[strlen(other.m_str)+1]; //分配空间容纳str内容
        strcpy(m_str, other.m_str); //复制other.m_str到私有成员m_str中
        return *this；
    }

    //拷贝构造函数
    String::String(const String &other){
        m_str = new char[strlen(other.m_str)+1]; //分配空间容纳str内容
        strcpy(m_str, other.m_str); //复制other.m_str到私有成员m_str中 
    }

18. sizeof一个类求大小,变量、对象、指针、类等等;

19. 指针和引用的区别;

20. 多重类构造和析构的顺序(对称);

21. stl各容器的实现原理（必考）;

22. extern c 是干啥的（必须将编译器的函数名修饰的机制解答的很透彻）;
23. volatile是干啥用的，（必须将cpu的寄存器缓存机制回答的很透彻）;
24. static const等等的用法;
