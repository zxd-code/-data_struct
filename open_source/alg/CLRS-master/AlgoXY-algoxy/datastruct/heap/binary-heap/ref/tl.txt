
Heap Sort in FP
Options
There are currently too many topics in this group that display first. To make this topic appear first, remove this option from another topic.
There was an error processing your request. Please try again.
Standard view   View as tree
Proportional text   Fixed font
[Click the envelope to receive email updates] 	Email updates to meCancel my email updates
	
		
[Click the star to watch this topic] 	
[Click the envelope to receive email updates]
	
flag
	  	25 messages - 1 new - Collapse all  -  Translate all to English Translated (View all originals)  - 
Report discussion as spam
Reporting discussion
Messages reported
	
The group you are posting to is a Usenet group. Messages posted to this group will make your email address visible to anyone on the Internet.
Your reply message has not been sent.
Your post was successful
Cancel
		
		
Send  Discard
		
		
From: 	
To: 	
Cc: 	
Followup To: 	
	
Add Cc | Add Followup-to | Edit Subject 	
Subject: 	
		
Validation: 	
For verification purposes please type the characters you see in the picture below or the numbers you hear by clicking the accessibility icon. Listen and type the numbers you hear
Send  Discard
	
	
		
liuxinyu   	
View profile   Translate to English Translated (View Original)
	 More options Sep 6, 5:27 pm
From: liuxinyu <liuxiny...@gmail.com>
Date: Mon, 6 Sep 2010 02:27:22 -0700 (PDT)
Local: Mon, Sep 6 2010 5:27 pm
Subject: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Remove | Report this message | Find messages by this author
Hi,

刚才有朋友在B-tree那个thread里问Heap Sort的FP实现能否达到O(lgN)。

我略微查了一下，Haskell的mail list里，在1997年的时候有人讨论过这个：
http://www.mail-archive.com/hask...@haskell.org/msg01788.html

有人还给出了对照的merge sort:
http://www.mail-archive.com/hask...@haskell.org/msg01816.html

但是Chris Okasaki指出，实际上Jon用的不是Binary Heap，而是FP中使用的multi-pass binary
heap。
在Chris Okasaki的博士论文和他的书中，有一系列对Heap的FP实现，包括Leftist Heap, Binomial Heap,
Pairing Heap等等。

在标准的Haskell库中Hackage给出的heapsort正是采用了pairing heap：
http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/...

我先占个位置，然后有时间的话，会给出详细的介绍。

-- 
刘
https://sites.google.com/site/algoxy/home

    Reply     Reply to author     Forward  
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
liuxinyu   	
View profile   Translate to English Translated (View Original)
	 More options Sep 6, 5:34 pm
From: liuxinyu <liuxiny...@gmail.com>
Date: Mon, 6 Sep 2010 02:34:24 -0700 (PDT)
Local: Mon, Sep 6 2010 5:34 pm
Subject: Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Remove | Report this message | Find messages by this author
Hi,

1986年时，前辈们的论文:
http://www.cs.cmu.edu/~sleator/papers/pairing-heaps.pdf

-- 
liu

On Sep 6, 5:27 pm, liuxinyu <liuxiny...@gmail.com> wrote:

- Hide quoted text -
- Show quoted text -
> Hi,

> 刚才有朋友在B-tree那个thread里问Heap Sort的FP实现能否达到O(lgN)。

> 我略微查了一下，Haskell的mail list里，在1997年的时候有人讨论过这个：
> http://www.mail-archive.com/hask...@haskell.org/msg01788.html

> 有人还给出了对照的merge sort:
> http://www.mail-archive.com/hask...@haskell.org/msg01816.html

> 但是Chris Okasaki指出，实际上Jon用的不是Binary Heap，而是FP中使用的multi-pass binary
> heap。
> 在Chris Okasaki的博士论文和他的书中，有一系列对Heap的FP实现，包括Leftist Heap, Binomial Heap,
> Pairing Heap等等。

> 在标准的Haskell库中Hackage给出的heapsort正是采用了pairing heap：http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/...

> 我先占个位置，然后有时间的话，会给出详细的介绍。

> --
> 刘https://sites.google.com/site/algoxy/home


    Reply     Reply to author     Forward  
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
Doyle   	
View profile   Translate to English Translated (View Original)
	 More options Sep 7, 10:59 am
From: Doyle <doyle...@gmail.com>
Date: Tue, 7 Sep 2010 10:59:44 +0800
Local: Tues, Sep 7 2010 10:59 am
Subject: Re: [TL] Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author

看看代码,等详细介绍

2010/9/6 liuxinyu <liuxiny...@gmail.com>

- Hide quoted text -
- Show quoted text -
> Hi,

> 刚才有朋友在B-tree那个thread里问Heap Sort的FP实现能否达到O(lgN)。

> 我略微查了一下，Haskell的mail list里，在1997年的时候有人讨论过这个：
> http://www.mail-archive.com/hask...@haskell.org/msg01788.html

> 有人还给出了对照的merge sort:
> http://www.mail-archive.com/hask...@haskell.org/msg01816.html

> 但是Chris Okasaki指出，实际上Jon用的不是Binary Heap，而是FP中使用的multi-pass binary
> heap。
> 在Chris Okasaki的博士论文和他的书中，有一系列对Heap的FP实现，包括Leftist Heap, Binomial Heap,
> Pairing Heap等等。

> 在标准的Haskell库中Hackage给出的heapsort正是采用了pairing heap：

> http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/...

> 我先占个位置，然后有时间的话，会给出详细的介绍。

> --
> 刘
> https://sites.google.com/site/algoxy/home


    Reply     Reply to author     Forward       
Report spam
Reporting spam
Message reported
    Rate this post: Text for clearing space
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
jigsaw   	
View profile   Translate to English Translated (View Original)
	 More options Sep 17, 7:03 pm
From: jigsaw <jig...@gmail.com>
Date: Fri, 17 Sep 2010 04:03:01 -0700 (PDT)
Local: Fri, Sep 17 2010 7:03 pm
Subject: Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author
谢谢楼主推荐。
这算法漂亮的地方有2点：1 为纯FP而生的，用纯fp写起来非常自然  2 除了delete min，其它操作都是O(1)
但我用c写了一遍，发现效率比最简单的数组实现的binary heap低。
排除了malloc的干扰之后，gprof了一下，瓶颈在于：
1 每次insert时，node里2或3个指针赋值很费时间。而数组实现，尽管是logn的插入复杂度，但是每次swap的代价很小
2 每次delete min时，剪切节点时对每个节点有2或3个指针的赋值。

看起来是代价很小的操作，改变几个指针而已，却成为了瓶颈。看来数组真的是很猛，可以填平logn和1的差距。

我的实现里，每个node用了3个指针，而论文提出的可以用2个。论文已经说了，用2个指针是时间换空间，会给复杂度带来一个constant
factor。但不知道在实际运行中，会不会因为减少了给指针赋值的次数而反而带来好处。

更进一步的想法是，在paring步骤时，可以并发的操作，而paring正是gprof中显示最重的一个操作。如果能利用这个特性，也许可以带来显著
的加速度。但如果没有编译器/语言/甚至硬件的帮助，实现起来。。。坦率的说我不知道具体应该怎么实现。

不知道楼主有没有兴趣继续这个话题

On Sep 6, 12:34 pm, liuxinyu <liuxiny...@gmail.com> wrote:

- Hide quoted text -
- Show quoted text -
> Hi,

> 1986年时，前辈们的论文:http://www.cs.cmu.edu/~sleator/papers/pairing-heaps.pdf

> --
> liu

> On Sep 6, 5:27 pm, liuxinyu <liuxiny...@gmail.com> wrote:

> > Hi,

> > 刚才有朋友在B-tree那个thread里问Heap Sort的FP实现能否达到O(lgN)。

> > 我略微查了一下，Haskell的mail list里，在1997年的时候有人讨论过这个：
> > http://www.mail-archive.com/hask...@haskell.org/msg01788.html

> > 有人还给出了对照的merge sort:
> > http://www.mail-archive.com/hask...@haskell.org/msg01816.html

> > 但是Chris Okasaki指出，实际上Jon用的不是Binary Heap，而是FP中使用的multi-pass binary
> > heap。
> > 在Chris Okasaki的博士论文和他的书中，有一系列对Heap的FP实现，包括Leftist Heap, Binomial Heap,
> > Pairing Heap等等。

> > 在标准的Haskell库中Hackage给出的heapsort正是采用了pairing heap：http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/...

> > 我先占个位置，然后有时间的话，会给出详细的介绍。

> > --
> > 刘https://sites.google.com/site/algoxy/home


    Reply     Reply to author     Forward       
Report spam
Reporting spam
Message reported
    Rate this post: Text for clearing space
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
jigsaw   	
View profile   Translate to English Translated (View Original)
	 More options Sep 18, 5:24 am
From: jigsaw <jig...@gmail.com>
Date: Sat, 18 Sep 2010 00:24:51 +0300
Local: Sat, Sep 18 2010 5:24 am
Subject: Re: [TL] Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author

微调了下pair和merge部分，速度超过了binary
heap；跟nginx的rbtree比较了一下，插入100万/删除100万随机数据，比rbtree快~50%。
gporf显示paring
heap的瓶颈还是pair部分；而rbtree则是insert。这个跟纸上谈兵的预测是一致的。这个插入O(1)的本事的确是很少见。
haproxy搞了个很畸形的elastic tree（记得是这个名字），不仅算法畸形，而且wiki上的词条更畸形，无爱。

如果要打并发的主意，就是每次循环做N对pair，开N个县城。用pthread很不方便，openmp也许简单些，没有细想，因为这些都是user
space的东西，对我来说没用。
如果直接用汇编写的话，可能可以偷到一些性能，但是编程的代价大了点，目前看不出有那个必要。

这类不依赖数组的树，有个共同的问题，就是依赖于allocator或者gc的性能。
allocator的问题是对多核不友好。目前kernel的slab对多核不友好。solaris这方面是有成熟例子的，但不知道为什么这么多年了都没有影响到linux
kernel。这方面奥利弗-杨可能有话要说？
我发现kernel的实现都很保守，稍微先进点的东西在kernel里是找不到例子的。不说别的，就2.6的tcp/ip层就灰常的不被待见。高性能的tcp/ip层要么是基于2.4，要么是基于bsd。

最后，paring heap有些升级版，但是不打算研究了。

2010/9/17 jigsaw <jig...@gmail.com>

- Hide quoted text -
- Show quoted text -
> 谢谢楼主推荐。
> 这算法漂亮的地方有2点：1 为纯FP而生的，用纯fp写起来非常自然  2 除了delete min，其它操作都是O(1)
> 但我用c写了一遍，发现效率比最简单的数组实现的binary heap低。
> 排除了malloc的干扰之后，gprof了一下，瓶颈在于：
> 1 每次insert时，node里2或3个指针赋值很费时间。而数组实现，尽管是logn的插入复杂度，但是每次swap的代价很小
> 2 每次delete min时，剪切节点时对每个节点有2或3个指针的赋值。

> 看起来是代价很小的操作，改变几个指针而已，却成为了瓶颈。看来数组真的是很猛，可以填平logn和1的差距。

> 我的实现里，每个node用了3个指针，而论文提出的可以用2个。论文已经说了，用2个指针是时间换空间，会给复杂度带来一个constant
> factor。但不知道在实际运行中，会不会因为减少了给指针赋值的次数而反而带来好处。

> 更进一步的想法是，在paring步骤时，可以并发的操作，而paring正是gprof中显示最重的一个操作。如果能利用这个特性，也许可以带来显著
> 的加速度。但如果没有编译器/语言/甚至硬件的帮助，实现起来。。。坦率的说我不知道具体应该怎么实现。

> 不知道楼主有没有兴趣继续这个话题

> On Sep 6, 12:34 pm, liuxinyu <liuxiny...@gmail.com> wrote:
> > Hi,

> > 1986年时，前辈们的论文:http://www.cs.cmu.edu/~sleator/papers/pairing-heaps.pdf

> > --
> > liu

> > On Sep 6, 5:27 pm, liuxinyu <liuxiny...@gmail.com> wrote:

> > > Hi,

> > > 刚才有朋友在B-tree那个thread里问Heap Sort的FP实现能否达到O(lgN)。

> > > 我略微查了一下，Haskell的mail list里，在1997年的时候有人讨论过这个：
> > > http://www.mail-archive.com/hask...@haskell.org/msg01788.html

> > > 有人还给出了对照的merge sort:
> > > http://www.mail-archive.com/hask...@haskell.org/msg01816.html

> > > 但是Chris Okasaki指出，实际上Jon用的不是Binary Heap，而是FP中使用的multi-pass binary
> > > heap。
> > > 在Chris Okasaki的博士论文和他的书中，有一系列对Heap的FP实现，包括Leftist Heap, Binomial Heap,
> > > Pairing Heap等等。

> > > 在标准的Haskell库中Hackage给出的heapsort正是采用了pairing heap：
> http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/...

> > > 我先占个位置，然后有时间的话，会给出详细的介绍。

> > > --
> > > 刘https://sites.google.com/site/algoxy/home


    Reply     Reply to author     Forward       
Report spam
Reporting spam
Message reported
    Rate this post: Text for clearing space
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
oliver yang   	
View profile   Translate to English Translated (View Original)
	 More options Sep 18, 9:28 pm
From: oliver yang <yangoli...@gmail.com>
Date: Sat, 18 Sep 2010 21:28:36 +0800
Local: Sat, Sep 18 2010 9:28 pm
Subject: Re: [TL] Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author
在 2010年9月18日 上午5:24，jigsaw <jig...@gmail.com> 写道：

> 微调了下pair和merge部分，速度超过了binary
> heap；跟nginx的rbtree比较了一下，插入100万/删除100万随机数据，比rbtree快~50%。
> gporf显示paring
> heap的瓶颈还是pair部分；而rbtree则是insert。这个跟纸上谈兵的预测是一致的。这个插入O(1)的本事的确是很少见。
> haproxy搞了个很畸形的elastic tree（记得是这个名字），不仅算法畸形，而且wiki上的词条更畸形，无爱。
> 如果要打并发的主意，就是每次循环做N对pair，开N个县城。用pthread很不方便，openmp也许简单些，没有细想，因为这些都是user
> space的东西，对我来说没用。
> 如果直接用汇编写的话，可能可以偷到一些性能，但是编程的代价大了点，目前看不出有那个必要。
> 这类不依赖数组的树，有个共同的问题，就是依赖于allocator或者gc的性能。
> allocator的问题是对多核不友好。目前kernel的slab对多核不友好。solaris这方面是有成熟例子的，但不知道为什么这么多年了都没有影响到linux
> kernel。这方面奥利弗-杨可能有话要说？

Linux内核已经很久没有研究，不清楚内存管理方面现在的动向。

Solaris为了防止多核的在内存分配上的竞争，实现了一个per-CPU的cache, 叫做magazine layer.

有一个paper里面讲在实现slab以后如何去解决多CPU的全局锁竞争问题的，作者之一就是ZFS和Slab的创造者：Jeff Bonwick
and Jonathan Adams -  Magazines and vmem: Extending the Slab Allocator
to Many CPUs and Arbitrary Resources

- Hide quoted text -
- Show quoted text -
> 我发现kernel的实现都很保守，稍微先进点的东西在kernel里是找不到例子的。不说别的，就2.6的tcp/ip层就灰常的不被待见。高性能的tcp/ip层要么是基于2.4，要么是基于bsd。
> 最后，paring heap有些升级版，但是不打算研究了。

> 2010/9/17 jigsaw <jig...@gmail.com>

>> 谢谢楼主推荐。
>> 这算法漂亮的地方有2点：1 为纯FP而生的，用纯fp写起来非常自然  2 除了delete min，其它操作都是O(1)
>> 但我用c写了一遍，发现效率比最简单的数组实现的binary heap低。
>> 排除了malloc的干扰之后，gprof了一下，瓶颈在于：
>> 1 每次insert时，node里2或3个指针赋值很费时间。而数组实现，尽管是logn的插入复杂度，但是每次swap的代价很小
>> 2 每次delete min时，剪切节点时对每个节点有2或3个指针的赋值。

>> 看起来是代价很小的操作，改变几个指针而已，却成为了瓶颈。看来数组真的是很猛，可以填平logn和1的差距。

>> 我的实现里，每个node用了3个指针，而论文提出的可以用2个。论文已经说了，用2个指针是时间换空间，会给复杂度带来一个constant
>> factor。但不知道在实际运行中，会不会因为减少了给指针赋值的次数而反而带来好处。

>> 更进一步的想法是，在paring步骤时，可以并发的操作，而paring正是gprof中显示最重的一个操作。如果能利用这个特性，也许可以带来显著
>> 的加速度。但如果没有编译器/语言/甚至硬件的帮助，实现起来。。。坦率的说我不知道具体应该怎么实现。

>> 不知道楼主有没有兴趣继续这个话题

>> On Sep 6, 12:34 pm, liuxinyu <liuxiny...@gmail.com> wrote:
>> > Hi,

>> > 1986年时，前辈们的论文:http://www.cs.cmu.edu/~sleator/papers/pairing-heaps.pdf

>> > --
>> > liu

>> > On Sep 6, 5:27 pm, liuxinyu <liuxiny...@gmail.com> wrote:

>> > > Hi,

>> > > 刚才有朋友在B-tree那个thread里问Heap Sort的FP实现能否达到O(lgN)。

>> > > 我略微查了一下，Haskell的mail list里，在1997年的时候有人讨论过这个：
>> > > http://www.mail-archive.com/hask...@haskell.org/msg01788.html

>> > > 有人还给出了对照的merge sort:
>> > > http://www.mail-archive.com/hask...@haskell.org/msg01816.html

>> > > 但是Chris Okasaki指出，实际上Jon用的不是Binary Heap，而是FP中使用的multi-pass binary
>> > > heap。
>> > > 在Chris Okasaki的博士论文和他的书中，有一系列对Heap的FP实现，包括Leftist Heap, Binomial Heap,
>> > > Pairing Heap等等。

>> > > 在标准的Haskell库中Hackage给出的heapsort正是采用了pairing
>> > > heap：http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/...

>> > > 我先占个位置，然后有时间的话，会给出详细的介绍。

>> > > --
>> > > 刘https://sites.google.com/site/algoxy/home

-- 
Cheers,

Oliver Yang

Twitter: http://twitter.com/yangoliver
Blog:    http://blog.csdn.net/yayong
--------------------------------------------------------------------
An OpenSolaris Developer

    Reply     Reply to author     Forward       
Report spam
Reporting spam
Message reported
    Rate this post: Text for clearing space
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
jigsaw   	
View profile   Translate to English Translated (View Original)
	 More options Sep 18, 9:42 pm
From: jigsaw <jig...@gmail.com>
Date: Sat, 18 Sep 2010 16:42:36 +0300
Local: Sat, Sep 18 2010 9:42 pm
Subject: Re: [TL] Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author

嗯，我说的就是这个magazine。
不过刚看了下，linux kernel里也是这个设计。

2010/9/18 oliver yang <yangoli...@gmail.com>

- Hide quoted text -
- Show quoted text -
> 在 2010年9月18日 上午5:24，jigsaw <jig...@gmail.com> 写道：
> > 微调了下pair和merge部分，速度超过了binary
> > heap；跟nginx的rbtree比较了一下，插入100万/删除100万随机数据，比rbtree快~50%。
> > gporf显示paring
> > heap的瓶颈还是pair部分；而rbtree则是insert。这个跟纸上谈兵的预测是一致的。这个插入O(1)的本事的确是很少见。
> > haproxy搞了个很畸形的elastic tree（记得是这个名字），不仅算法畸形，而且wiki上的词条更畸形，无爱。
> > 如果要打并发的主意，就是每次循环做N对pair，开N个县城。用pthread很不方便，openmp也许简单些，没有细想，因为这些都是user
> > space的东西，对我来说没用。
> > 如果直接用汇编写的话，可能可以偷到一些性能，但是编程的代价大了点，目前看不出有那个必要。
> > 这类不依赖数组的树，有个共同的问题，就是依赖于allocator或者gc的性能。

> allocator的问题是对多核不友好。目前kernel的slab对多核不友好。solaris这方面是有成熟例子的，但不知道为什么这么多年了都没有影响到linux
> > kernel。这方面奥利弗-杨可能有话要说？

> Linux内核已经很久没有研究，不清楚内存管理方面现在的动向。

> Solaris为了防止多核的在内存分配上的竞争，实现了一个per-CPU的cache, 叫做magazine layer.

> 有一个paper里面讲在实现slab以后如何去解决多CPU的全局锁竞争问题的，作者之一就是ZFS和Slab的创造者：Jeff Bonwick
> and Jonathan Adams -  Magazines and vmem: Extending the Slab Allocator
> to Many CPUs and Arbitrary Resources

> 我发现kernel的实现都很保守，稍微先进点的东西在kernel里是找不到例子的。不说别的，就2.6的tcp/ip层就灰常的不被待见。高性能的tcp/ip层要么是基于2.4，要么是基于bsd。
> > 最后，paring heap有些升级版，但是不打算研究了。

> > 2010/9/17 jigsaw <jig...@gmail.com>

> >> 谢谢楼主推荐。
> >> 这算法漂亮的地方有2点：1 为纯FP而生的，用纯fp写起来非常自然  2 除了delete min，其它操作都是O(1)
> >> 但我用c写了一遍，发现效率比最简单的数组实现的binary heap低。
> >> 排除了malloc的干扰之后，gprof了一下，瓶颈在于：
> >> 1 每次insert时，node里2或3个指针赋值很费时间。而数组实现，尽管是logn的插入复杂度，但是每次swap的代价很小
> >> 2 每次delete min时，剪切节点时对每个节点有2或3个指针的赋值。

> >> 看起来是代价很小的操作，改变几个指针而已，却成为了瓶颈。看来数组真的是很猛，可以填平logn和1的差距。

> >> 我的实现里，每个node用了3个指针，而论文提出的可以用2个。论文已经说了，用2个指针是时间换空间，会给复杂度带来一个constant
> >> factor。但不知道在实际运行中，会不会因为减少了给指针赋值的次数而反而带来好处。

> >> 更进一步的想法是，在paring步骤时，可以并发的操作，而paring正是gprof中显示最重的一个操作。如果能利用这个特性，也许可以带来显著
> >> 的加速度。但如果没有编译器/语言/甚至硬件的帮助，实现起来。。。坦率的说我不知道具体应该怎么实现。

> >> 不知道楼主有没有兴趣继续这个话题

> >> On Sep 6, 12:34 pm, liuxinyu <liuxiny...@gmail.com> wrote:
> >> > Hi,

> >> > 1986年时，前辈们的论文:http://www.cs.cmu.edu/~sleator/papers/pairing-heaps.pdf

> >> > --
> >> > liu

> >> > On Sep 6, 5:27 pm, liuxinyu <liuxiny...@gmail.com> wrote:

> >> > > Hi,

> >> > > 刚才有朋友在B-tree那个thread里问Heap Sort的FP实现能否达到O(lgN)。

> >> > > 我略微查了一下，Haskell的mail list里，在1997年的时候有人讨论过这个：
> >> > > http://www.mail-archive.com/hask...@haskell.org/msg01788.html

> >> > > 有人还给出了对照的merge sort:
> >> > > http://www.mail-archive.com/hask...@haskell.org/msg01816.html

> >> > > 但是Chris Okasaki指出，实际上Jon用的不是Binary Heap，而是FP中使用的multi-pass binary
> >> > > heap。
> >> > > 在Chris Okasaki的博士论文和他的书中，有一系列对Heap的FP实现，包括Leftist Heap, Binomial
> Heap,
> >> > > Pairing Heap等等。

> >> > > 在标准的Haskell库中Hackage给出的heapsort正是采用了pairing
> >> > > heap：
> http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/...

> >> > > 我先占个位置，然后有时间的话，会给出详细的介绍。

> >> > > --
> >> > > 刘https://sites.google.com/site/algoxy/home

> --
> Cheers,

> Oliver Yang

> Twitter: http://twitter.com/yangoliver
> Blog:    http://blog.csdn.net/yayong
> --------------------------------------------------------------------
> An OpenSolaris Developer


    Reply     Reply to author     Forward       
Report spam
Reporting spam
Message reported
    Rate this post: Text for clearing space
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
oliver yang   	
View profile   Translate to English Translated (View Original)
	 More options Sep 18, 9:44 pm
From: oliver yang <yangoli...@gmail.com>
Date: Sat, 18 Sep 2010 21:44:55 +0800
Local: Sat, Sep 18 2010 9:44 pm
Subject: Re: [TL] Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author
在 2010年9月18日 下午9:42，jigsaw <jig...@gmail.com> 写道：

> 嗯，我说的就是这个magazine。
> 不过刚看了下，linux kernel里也是这个设计。

呵呵，这个想法很简单，也不难实现。

所以说Solaris对Linux的贡献很大的。

- Hide quoted text -
- Show quoted text -

> 2010/9/18 oliver yang <yangoli...@gmail.com>

>> 在 2010年9月18日 上午5:24，jigsaw <jig...@gmail.com> 写道：
>> > 微调了下pair和merge部分，速度超过了binary
>> > heap；跟nginx的rbtree比较了一下，插入100万/删除100万随机数据，比rbtree快~50%。
>> > gporf显示paring
>> > heap的瓶颈还是pair部分；而rbtree则是insert。这个跟纸上谈兵的预测是一致的。这个插入O(1)的本事的确是很少见。
>> > haproxy搞了个很畸形的elastic tree（记得是这个名字），不仅算法畸形，而且wiki上的词条更畸形，无爱。
>> > 如果要打并发的主意，就是每次循环做N对pair，开N个县城。用pthread很不方便，openmp也许简单些，没有细想，因为这些都是user
>> > space的东西，对我来说没用。
>> > 如果直接用汇编写的话，可能可以偷到一些性能，但是编程的代价大了点，目前看不出有那个必要。
>> > 这类不依赖数组的树，有个共同的问题，就是依赖于allocator或者gc的性能。

>> > allocator的问题是对多核不友好。目前kernel的slab对多核不友好。solaris这方面是有成熟例子的，但不知道为什么这么多年了都没有影响到linux
>> > kernel。这方面奥利弗-杨可能有话要说？

>> Linux内核已经很久没有研究，不清楚内存管理方面现在的动向。

>> Solaris为了防止多核的在内存分配上的竞争，实现了一个per-CPU的cache, 叫做magazine layer.

>> 有一个paper里面讲在实现slab以后如何去解决多CPU的全局锁竞争问题的，作者之一就是ZFS和Slab的创造者：Jeff Bonwick
>> and Jonathan Adams -  Magazines and vmem: Extending the Slab Allocator
>> to Many CPUs and Arbitrary Resources

>> > 我发现kernel的实现都很保守，稍微先进点的东西在kernel里是找不到例子的。不说别的，就2.6的tcp/ip层就灰常的不被待见。高性能的tcp/ip层要么是基于2.4，要么是基于bsd。
>> > 最后，paring heap有些升级版，但是不打算研究了。

>> > 2010/9/17 jigsaw <jig...@gmail.com>

>> >> 谢谢楼主推荐。
>> >> 这算法漂亮的地方有2点：1 为纯FP而生的，用纯fp写起来非常自然  2 除了delete min，其它操作都是O(1)
>> >> 但我用c写了一遍，发现效率比最简单的数组实现的binary heap低。
>> >> 排除了malloc的干扰之后，gprof了一下，瓶颈在于：
>> >> 1 每次insert时，node里2或3个指针赋值很费时间。而数组实现，尽管是logn的插入复杂度，但是每次swap的代价很小
>> >> 2 每次delete min时，剪切节点时对每个节点有2或3个指针的赋值。

>> >> 看起来是代价很小的操作，改变几个指针而已，却成为了瓶颈。看来数组真的是很猛，可以填平logn和1的差距。

>> >> 我的实现里，每个node用了3个指针，而论文提出的可以用2个。论文已经说了，用2个指针是时间换空间，会给复杂度带来一个constant
>> >> factor。但不知道在实际运行中，会不会因为减少了给指针赋值的次数而反而带来好处。

>> >> 更进一步的想法是，在paring步骤时，可以并发的操作，而paring正是gprof中显示最重的一个操作。如果能利用这个特性，也许可以带来显著
>> >> 的加速度。但如果没有编译器/语言/甚至硬件的帮助，实现起来。。。坦率的说我不知道具体应该怎么实现。

>> >> 不知道楼主有没有兴趣继续这个话题

>> >> On Sep 6, 12:34 pm, liuxinyu <liuxiny...@gmail.com> wrote:
>> >> > Hi,

>> >> > 1986年时，前辈们的论文:http://www.cs.cmu.edu/~sleator/papers/pairing-heaps.pdf

>> >> > --
>> >> > liu

>> >> > On Sep 6, 5:27 pm, liuxinyu <liuxiny...@gmail.com> wrote:

>> >> > > Hi,

>> >> > > 刚才有朋友在B-tree那个thread里问Heap Sort的FP实现能否达到O(lgN)。

>> >> > > 我略微查了一下，Haskell的mail list里，在1997年的时候有人讨论过这个：
>> >> > > http://www.mail-archive.com/hask...@haskell.org/msg01788.html

>> >> > > 有人还给出了对照的merge sort:
>> >> > > http://www.mail-archive.com/hask...@haskell.org/msg01816.html

>> >> > > 但是Chris Okasaki指出，实际上Jon用的不是Binary Heap，而是FP中使用的multi-pass binary
>> >> > > heap。
>> >> > > 在Chris Okasaki的博士论文和他的书中，有一系列对Heap的FP实现，包括Leftist Heap, Binomial
>> >> > > Heap,
>> >> > > Pairing Heap等等。

>> >> > > 在标准的Haskell库中Hackage给出的heapsort正是采用了pairing

>> >> > > heap：http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/...

>> >> > > 我先占个位置，然后有时间的话，会给出详细的介绍。

>> >> > > --
>> >> > > 刘https://sites.google.com/site/algoxy/home

>> --
>> Cheers,

>> Oliver Yang

>> Twitter: http://twitter.com/yangoliver
>> Blog:    http://blog.csdn.net/yayong
>> --------------------------------------------------------------------
>> An OpenSolaris Developer

-- 
Cheers,

Oliver Yang

Twitter: http://twitter.com/yangoliver
Blog:    http://blog.csdn.net/yayong
--------------------------------------------------------------------
An OpenSolaris Developer

    Reply     Reply to author     Forward       
Report spam
Reporting spam
Message reported
    Rate this post: Text for clearing space
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
jigsaw   	
View profile   Translate to English Translated (View Original)
	 More options Sep 18, 9:50 pm
From: jigsaw <jig...@gmail.com>
Date: Sat, 18 Sep 2010 16:50:54 +0300
Local: Sat, Sep 18 2010 9:50 pm
Subject: Re: [TL] Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author

solaris跟bsd的代码风格很像，有学院风，注释很漂亮，合我的口味。linux的山寨气比较重，代码的目录结构也比较乱，不是很喜欢。但linux是主流，没办法。

厄。。。跑题了

2010/9/18 oliver yang <yangoli...@gmail.com>

- Hide quoted text -
- Show quoted text -
> 在 2010年9月18日 下午9:42，jigsaw <jig...@gmail.com> 写道：
> > 嗯，我说的就是这个magazine。
> > 不过刚看了下，linux kernel里也是这个设计。

> 呵呵，这个想法很简单，也不难实现。

> 所以说Solaris对Linux的贡献很大的。

> > 2010/9/18 oliver yang <yangoli...@gmail.com>

> >> 在 2010年9月18日 上午5:24，jigsaw <jig...@gmail.com> 写道：
> >> > 微调了下pair和merge部分，速度超过了binary
> >> > heap；跟nginx的rbtree比较了一下，插入100万/删除100万随机数据，比rbtree快~50%。
> >> > gporf显示paring
> >> > heap的瓶颈还是pair部分；而rbtree则是insert。这个跟纸上谈兵的预测是一致的。这个插入O(1)的本事的确是很少见。
> >> > haproxy搞了个很畸形的elastic tree（记得是这个名字），不仅算法畸形，而且wiki上的词条更畸形，无爱。
> >> > 如果要打并发的主意，就是每次循环做N对pair，开N个县城。用pthread很不方便，openmp也许简单些，没有细想，因为这些都是user
> >> > space的东西，对我来说没用。
> >> > 如果直接用汇编写的话，可能可以偷到一些性能，但是编程的代价大了点，目前看不出有那个必要。
> >> > 这类不依赖数组的树，有个共同的问题，就是依赖于allocator或者gc的性能。

> allocator的问题是对多核不友好。目前kernel的slab对多核不友好。solaris这方面是有成熟例子的，但不知道为什么这么多年了都没有影响到linux
> >> > kernel。这方面奥利弗-杨可能有话要说？

> >> Linux内核已经很久没有研究，不清楚内存管理方面现在的动向。

> >> Solaris为了防止多核的在内存分配上的竞争，实现了一个per-CPU的cache, 叫做magazine layer.

> >> 有一个paper里面讲在实现slab以后如何去解决多CPU的全局锁竞争问题的，作者之一就是ZFS和Slab的创造者：Jeff Bonwick
> >> and Jonathan Adams -  Magazines and vmem: Extending the Slab Allocator
> >> to Many CPUs and Arbitrary Resources

> 我发现kernel的实现都很保守，稍微先进点的东西在kernel里是找不到例子的。不说别的，就2.6的tcp/ip层就灰常的不被待见。高性能的tcp/ip层要么是基于2.4，要么是基于bsd。
> >> > 最后，paring heap有些升级版，但是不打算研究了。

> >> > 2010/9/17 jigsaw <jig...@gmail.com>

> >> >> 谢谢楼主推荐。
> >> >> 这算法漂亮的地方有2点：1 为纯FP而生的，用纯fp写起来非常自然  2 除了delete min，其它操作都是O(1)
> >> >> 但我用c写了一遍，发现效率比最简单的数组实现的binary heap低。
> >> >> 排除了malloc的干扰之后，gprof了一下，瓶颈在于：
> >> >> 1 每次insert时，node里2或3个指针赋值很费时间。而数组实现，尽管是logn的插入复杂度，但是每次swap的代价很小
> >> >> 2 每次delete min时，剪切节点时对每个节点有2或3个指针的赋值。

> >> >> 看起来是代价很小的操作，改变几个指针而已，却成为了瓶颈。看来数组真的是很猛，可以填平logn和1的差距。

> >> >> 我的实现里，每个node用了3个指针，而论文提出的可以用2个。论文已经说了，用2个指针是时间换空间，会给复杂度带来一个constant
> >> >> factor。但不知道在实际运行中，会不会因为减少了给指针赋值的次数而反而带来好处。

> 更进一步的想法是，在paring步骤时，可以并发的操作，而paring正是gprof中显示最重的一个操作。如果能利用这个特性，也许可以带来显著
> >> >> 的加速度。但如果没有编译器/语言/甚至硬件的帮助，实现起来。。。坦率的说我不知道具体应该怎么实现。

> >> >> 不知道楼主有没有兴趣继续这个话题

> >> >> On Sep 6, 12:34 pm, liuxinyu <liuxiny...@gmail.com> wrote:
> >> >> > Hi,

> >> >> > 1986年时，前辈们的论文:
> http://www.cs.cmu.edu/~sleator/papers/pairing-heaps.pdf

> >> >> > --
> >> >> > liu

> >> >> > On Sep 6, 5:27 pm, liuxinyu <liuxiny...@gmail.com> wrote:

> >> >> > > Hi,

> >> >> > > 刚才有朋友在B-tree那个thread里问Heap Sort的FP实现能否达到O(lgN)。

> >> >> > > 我略微查了一下，Haskell的mail list里，在1997年的时候有人讨论过这个：
> >> >> > > http://www.mail-archive.com/hask...@haskell.org/msg01788.html

> >> >> > > 有人还给出了对照的merge sort:
> >> >> > > http://www.mail-archive.com/hask...@haskell.org/msg01816.html

> >> >> > > 但是Chris Okasaki指出，实际上Jon用的不是Binary Heap，而是FP中使用的multi-pass binary
> >> >> > > heap。
> >> >> > > 在Chris Okasaki的博士论文和他的书中，有一系列对Heap的FP实现，包括Leftist Heap, Binomial
> >> >> > > Heap,
> >> >> > > Pairing Heap等等。

> >> >> > > 在标准的Haskell库中Hackage给出的heapsort正是采用了pairing

> >> >> > > heap：
> http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/...

> >> >> > > 我先占个位置，然后有时间的话，会给出详细的介绍。

> >> >> > > --
> >> >> > > 刘https://sites.google.com/site/algoxy/home

> >> --
> >> Cheers,

> >> Oliver Yang

> >> Twitter: http://twitter.com/yangoliver
> >> Blog:    http://blog.csdn.net/yayong
> >> --------------------------------------------------------------------
> >> An OpenSolaris Developer

> --
> Cheers,

> Oliver Yang

> Twitter: http://twitter.com/yangoliver
> Blog:    http://blog.csdn.net/yayong
> --------------------------------------------------------------------
> An OpenSolaris Developer


    Reply     Reply to author     Forward       
Report spam
Reporting spam
Message reported
    Rate this post: Text for clearing space
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
liuxinyu   	
View profile   Translate to English Translated (View Original)
	 More options Sep 19, 2:06 pm
From: liuxinyu <liuxiny...@gmail.com>
Date: Sat, 18 Sep 2010 23:06:25 -0700 (PDT)
Local: Sun, Sep 19 2010 2:06 pm
Subject: Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Remove | Report this message | Find messages by this author
Hi,

强调一下，pairing heap的deleteMin的复杂度只是一个猜测，至今没有得到严格证明。
其实大多数叫客户对heap的定义容易让读者认为，只有``算法导论''那个以数组形式表现的数据结构才是heap。
STL中的heap, python中的heapq都是这样实现的。

然而广义的heap定义不是这样的，这种数据结构严格来讲叫做 implicit heap by array。
Knuth在TAOCP中，给出了leftist heap，我觉得把这几种heap结合起来看，就会有更全面的理解：
1. implicit heap by array (CLRS中介绍的heap)
2. binomial heap (CLRS中介绍的另一种heap)
3. leftist heap (TAOCP中介绍的heap，可以用FP实现)
4. Fibonacci heap (CLRS中有介绍，理论意义大于实际意义）
5. Pairing heap (理论证明尚不完善，绝大多数FP实现使用这种heap)

我现在越来越忙，感觉实在没法向过去那样不断post东西出来。只能尽力而已了。

-- 
刘

On Sep 18, 5:24 am, jigsaw <jig...@gmail.com> wrote:

- Hide quoted text -
- Show quoted text -
> 微调了下pair和merge部分，速度超过了binary
> heap；跟nginx的rbtree比较了一下，插入100万/删除100万随机数据，比rbtree快~50%。
> gporf显示paring
> heap的瓶颈还是pair部分；而rbtree则是insert。这个跟纸上谈兵的预测是一致的。这个插入O(1)的本事的确是很少见。
> haproxy搞了个很畸形的elastic tree（记得是这个名字），不仅算法畸形，而且wiki上的词条更畸形，无爱。

> 如果要打并发的主意，就是每次循环做N对pair，开N个县城。用pthread很不方便，openmp也许简单些，没有细想，因为这些都是user
> space的东西，对我来说没用。
> 如果直接用汇编写的话，可能可以偷到一些性能，但是编程的代价大了点，目前看不出有那个必要。

> 这类不依赖数组的树，有个共同的问题，就是依赖于allocator或者gc的性能。
> allocator的问题是对多核不友好。目前kernel的slab对多核不友好。solaris这方面是有成熟例子的，但不知道为什么这么多年了都没有影响到linux
> kernel。这方面奥利弗-杨可能有话要说？
> 我发现kernel的实现都很保守，稍微先进点的东西在kernel里是找不到例子的。不说别的，就2.6的tcp/ip层就灰常的不被待见。高性能的tcp/ip层要么是基于2.4，要么是基于bsd。

> 最后，paring heap有些升级版，但是不打算研究了。

> 2010/9/17 jigsaw <jig...@gmail.com>

> > 谢谢楼主推荐。
> > 这算法漂亮的地方有2点：1 为纯FP而生的，用纯fp写起来非常自然  2 除了delete min，其它操作都是O(1)
> > 但我用c写了一遍，发现效率比最简单的数组实现的binary heap低。
> > 排除了malloc的干扰之后，gprof了一下，瓶颈在于：
> > 1 每次insert时，node里2或3个指针赋值很费时间。而数组实现，尽管是logn的插入复杂度，但是每次swap的代价很小
> > 2 每次delete min时，剪切节点时对每个节点有2或3个指针的赋值。

> > 看起来是代价很小的操作，改变几个指针而已，却成为了瓶颈。看来数组真的是很猛，可以填平logn和1的差距。

> > 我的实现里，每个node用了3个指针，而论文提出的可以用2个。论文已经说了，用2个指针是时间换空间，会给复杂度带来一个constant
> > factor。但不知道在实际运行中，会不会因为减少了给指针赋值的次数而反而带来好处。

> > 更进一步的想法是，在paring步骤时，可以并发的操作，而paring正是gprof中显示最重的一个操作。如果能利用这个特性，也许可以带来显著
> > 的加速度。但如果没有编译器/语言/甚至硬件的帮助，实现起来。。。坦率的说我不知道具体应该怎么实现。

> > 不知道楼主有没有兴趣继续这个话题

> > On Sep 6, 12:34 pm, liuxinyu <liuxiny...@gmail.com> wrote:
> > > Hi,

> > > 1986年时，前辈们的论文:http://www.cs.cmu.edu/~sleator/papers/pairing-heaps.pdf

> > > --
> > > liu

> > > On Sep 6, 5:27 pm, liuxinyu <liuxiny...@gmail.com> wrote:

> > > > Hi,

> > > > 刚才有朋友在B-tree那个thread里问Heap Sort的FP实现能否达到O(lgN)。

> > > > 我略微查了一下，Haskell的mail list里，在1997年的时候有人讨论过这个：
> > > > http://www.mail-archive.com/hask...@haskell.org/msg01788.html

> > > > 有人还给出了对照的merge sort:
> > > > http://www.mail-archive.com/hask...@haskell.org/msg01816.html

> > > > 但是Chris Okasaki指出，实际上Jon用的不是Binary Heap，而是FP中使用的multi-pass binary
> > > > heap。
> > > > 在Chris Okasaki的博士论文和他的书中，有一系列对Heap的FP实现，包括Leftist Heap, Binomial Heap,
> > > > Pairing Heap等等。

> > > > 在标准的Haskell库中Hackage给出的heapsort正是采用了pairing heap：
> >http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/...

> > > > 我先占个位置，然后有时间的话，会给出详细的介绍。

> > > > --
> > > > 刘https://sites.google.com/site/algoxy/home


    Reply     Reply to author     Forward  
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
jigsaw   	
View profile   Translate to English Translated (View Original)
	 More options Sep 24, 6:41 am
From: jigsaw <jig...@gmail.com>
Date: Fri, 24 Sep 2010 01:41:43 +0300
Local: Fri, Sep 24 2010 6:41 am
Subject: Re: [TL] Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author

md好久没写scheme，手生了。。。

Scheme:

(define (make-root x)
  (cons x '()))

(define (find-min root)
  (car root))

(define (meld n m)
  (cond ((null? n) m)
((null? m) n)
((if (> (find-min n) (find-min m))
     (append (make-root (find-min m))
     (list n)
     (cdr m))
     (append (make-root (find-min n))
     (list m)
     (cdr n))))))

(define (insert root x)
  (meld root (make-root x)))

(define (delete-min root)
  (define (delete-min-iter result root)
    (cond ((null? root) result)
  ((null? (cdr root)) (meld result (car root)))
  ((let ((m (car root))
 (n (cadr root)))
     (delete-min-iter (meld m n) (cddr root))))))
  (delete-min-iter '() (cdr root)))

;(define xxx (insert (insert (insert (insert (make-root 10) 9) 12) 7) 19))
;(delete-min xxx)
;(delete-min (delete-min (delete-min (delete-min (delete-min xxx)))))

2010/9/19 liuxinyu <liuxiny...@gmail.com>:

- Hide quoted text -
- Show quoted text -
> Hi,

> 强调一下，pairing heap的deleteMin的复杂度只是一个猜测，至今没有得到严格证明。
> 其实大多数叫客户对heap的定义容易让读者认为，只有``算法导论''那个以数组形式表现的数据结构才是heap。
> STL中的heap, python中的heapq都是这样实现的。

> 然而广义的heap定义不是这样的，这种数据结构严格来讲叫做 implicit heap by array。
> Knuth在TAOCP中，给出了leftist heap，我觉得把这几种heap结合起来看，就会有更全面的理解：
> 1. implicit heap by array (CLRS中介绍的heap)
> 2. binomial heap (CLRS中介绍的另一种heap)
> 3. leftist heap (TAOCP中介绍的heap，可以用FP实现)
> 4. Fibonacci heap (CLRS中有介绍，理论意义大于实际意义）
> 5. Pairing heap (理论证明尚不完善，绝大多数FP实现使用这种heap)

> 我现在越来越忙，感觉实在没法向过去那样不断post东西出来。只能尽力而已了。

> --
> 刘

> On Sep 18, 5:24 am, jigsaw <jig...@gmail.com> wrote:
>> 微调了下pair和merge部分，速度超过了binary
>> heap；跟nginx的rbtree比较了一下，插入100万/删除100万随机数据，比rbtree快~50%。
>> gporf显示paring
>> heap的瓶颈还是pair部分；而rbtree则是insert。这个跟纸上谈兵的预测是一致的。这个插入O(1)的本事的确是很少见。
>> haproxy搞了个很畸形的elastic tree（记得是这个名字），不仅算法畸形，而且wiki上的词条更畸形，无爱。

>> 如果要打并发的主意，就是每次循环做N对pair，开N个县城。用pthread很不方便，openmp也许简单些，没有细想，因为这些都是user
>> space的东西，对我来说没用。
>> 如果直接用汇编写的话，可能可以偷到一些性能，但是编程的代价大了点，目前看不出有那个必要。

>> 这类不依赖数组的树，有个共同的问题，就是依赖于allocator或者gc的性能。

allocator的问题是对多核不友好。目前kernel的slab对多核不友好。solaris这方面是有成熟例子的，但不知道为什么这么多年了都没有影响到linux
>> kernel。这方面奥利弗-杨可能有话要说？

我发现kernel的实现都很保守，稍微先进点的东西在kernel里是找不到例子的。不说别的，就2.6的tcp/ip层就灰常的不被待见。高性能的tcp/ip层要么是基于2.4，要么是基于bsd。

- Hide quoted text -
- Show quoted text -

>> 最后，paring heap有些升级版，但是不打算研究了。

>> 2010/9/17 jigsaw <jig...@gmail.com>

>> > 谢谢楼主推荐。
>> > 这算法漂亮的地方有2点：1 为纯FP而生的，用纯fp写起来非常自然  2 除了delete min，其它操作都是O(1)
>> > 但我用c写了一遍，发现效率比最简单的数组实现的binary heap低。
>> > 排除了malloc的干扰之后，gprof了一下，瓶颈在于：
>> > 1 每次insert时，node里2或3个指针赋值很费时间。而数组实现，尽管是logn的插入复杂度，但是每次swap的代价很小
>> > 2 每次delete min时，剪切节点时对每个节点有2或3个指针的赋值。

>> > 看起来是代价很小的操作，改变几个指针而已，却成为了瓶颈。看来数组真的是很猛，可以填平logn和1的差距。

>> > 我的实现里，每个node用了3个指针，而论文提出的可以用2个。论文已经说了，用2个指针是时间换空间，会给复杂度带来一个constant
>> > factor。但不知道在实际运行中，会不会因为减少了给指针赋值的次数而反而带来好处。

>> > 更进一步的想法是，在paring步骤时，可以并发的操作，而paring正是gprof中显示最重的一个操作。如果能利用这个特性，也许可以带来显著
>> > 的加速度。但如果没有编译器/语言/甚至硬件的帮助，实现起来。。。坦率的说我不知道具体应该怎么实现。

>> > 不知道楼主有没有兴趣继续这个话题

>> > On Sep 6, 12:34 pm, liuxinyu <liuxiny...@gmail.com> wrote:
>> > > Hi,

>> > > 1986年时，前辈们的论文:http://www.cs.cmu.edu/~sleator/papers/pairing-heaps.pdf

>> > > --
>> > > liu

>> > > On Sep 6, 5:27 pm, liuxinyu <liuxiny...@gmail.com> wrote:

>> > > > Hi,

>> > > > 刚才有朋友在B-tree那个thread里问Heap Sort的FP实现能否达到O(lgN)。

>> > > > 我略微查了一下，Haskell的mail list里，在1997年的时候有人讨论过这个：
>> > > > http://www.mail-archive.com/hask...@haskell.org/msg01788.html

>> > > > 有人还给出了对照的merge sort:
>> > > > http://www.mail-archive.com/hask...@haskell.org/msg01816.html

>> > > > 但是Chris Okasaki指出，实际上Jon用的不是Binary Heap，而是FP中使用的multi-pass binary
>> > > > heap。
>> > > > 在Chris Okasaki的博士论文和他的书中，有一系列对Heap的FP实现，包括Leftist Heap, Binomial
Heap,
>> > > > Pairing Heap等等。

>> > > > 在标准的Haskell库中Hackage给出的heapsort正是采用了pairing heap：
>> >http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/src/...

>> > > > 我先占个位置，然后有时间的话，会给出详细的介绍。

>> > > > --
>> > > > 刘https://sites.google.com/site/algoxy/home


    Reply     Reply to author     Forward       
Report spam
Reporting spam
Message reported
    Rate this post: Text for clearing space
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
liuxinyu   	
View profile   Translate to English Translated (View Original)
	 More options Sep 25, 5:22 pm
From: liuxinyu <liuxiny...@gmail.com>
Date: Sat, 25 Sep 2010 02:22:53 -0700 (PDT)
Local: Sat, Sep 25 2010 5:22 pm
Subject: Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Remove | Report this message | Find messages by this author
Hi,

今天抽出点时间。

我们慢慢来，先复习下算法导论（CLRS）中的binary heap。
导论课本中给出的binary heap实际是recursive实现的。如果大家翻看STL的heap或者python的heapq，就会发现实现上
略有差别。尤其是heap sort的实现。

正如在前面post中提到的，我们打算把各种heap统一对比来看。所以这里给出一个区别于CLRS的heap定义（广义定义）：
一个heap（堆）是这样一个数据结构，
* 它有一个顶，保存着最小（大）值；
* 它可以支持弹出堆顶元素的操作，弹出后的堆仍然保持的堆的特性，也就是堆顶元素最小（大）；
* 它支持插入操作，插入一个新值后，仍然保持堆的特性，也就是堆顶元素最小（大）；

还有其他一些可选操作，如：
* 可以把两个堆合并(merge)成一个堆，合并后，仍然保持堆的特性，也就是堆顶元素最小（大）

根据这个定义，我们发现可以用多种更基本的数据结构来实现堆，只要它满足上述的定义即可。其中最简单直接的一种解法是树，只要保持树根永远最小（大）就
可以了。
注意，这里我没有说一定是二叉树，凡是用二叉树实现的heap，称之为binary heap。

CLRS中第6章给出的binary heap，实际上严格讲应该叫做implicit binary heap by array，也就是用
array实现的隐式heap。
其本质思想是把array的index对应到二叉树的节点上的一个map，这个map用c++和python这样以0作为数组起始index的语言来
说，可以定义如下（这里用python)
def parent(i):
    return (i+1)//2-1

def left(i):
    return  2*i+1

def right(i):
    return 2*(i+1)
注意，这里的定义和CLRS的有区别，原因是CLRS的数组从1开始。//表示取整除法。当然，在实际代码中，为了增加速度，可以使用移位运算符>>或
<<，如C++/STL和python
的heapq都是如此。

这一map定义了如何从第i个数组元素，找到其对应的二叉树上的父节点，左子节点，和右子节点。
举个例子，数组[16, 4, 10, 14, 7, 9, 3, 2, 8, 1]对应了二叉树：
((((2 14 8)) 4 ((1 7 .))) 16 (9 10 3)) 这里的二叉树使用in-order来表示。

为了generic，我抽象了两个比较运算：
MIN_HEAP = lambda a, b: a < b
MAX_HEAP = lambda a, b: a > b
也就是小于运算用于min-heap(小顶堆)，大于运算用于max-heap（大顶堆）

有了这个隐式数组表示，就可以实现最核心的heapify函数了，这个算法用递归的表达非常直观：
如果数组中第i个元素对应到某个子树的树根节点，那么这个子树如果满足heap的性质，则树根节点必须子树中所有元素中最小（大）的。
为此：
平凡情况：若此节点是一个叶子节点，退出；
一般情况：检查此节点的左右子节点，找出最小（大）的一个，和此节点交换，然后递归heapify交换后的子树。

CLRS上给出的MAX-HEAPIFY算法就是这个递归算法的 pseudo code 的描述，可以把它改为纯imperative实现，消除这个
递归，如下：

def heapify(x, i):
    n = len(x)
    while True:
        l = left(i)
        r = right(i)
        largest = i
        if l < n and x[l] < x[i]:
            largest = l
        if r < n and x[r] < x[largest]:
            largest = r
        if largest != i:
            (x[i], x[largest])=(x[largest], x[i])
            i  = largest
        else:
            break

注意，这里用的是小顶堆。为了通用，我们可以引入less_p，就是把用来判断大小的关系运算抽象出来：
# min-heapify by default
def heapify(x, i, less_p = MIN_HEAP):
    n = len(x)
    while True:
        l = left(i)
        r = right(i)
        largest = i
        if l < n and less_p(x[l], x[i]):
            largest = l
        if r < n and less_p(x[r], x[largest]):
            largest = r
        if largest != i:
            (x[i], x[largest])=(x[largest], x[i])
            i  = largest
        else:
            break

为了验证其正确性，我们可以使用CLRS的figure 6.2来测试下：
class TestHeap:
    def __init__(self):
        print "Implicit binary heap by array testing"

    def run(self):
        self.test_heapify()

    def __assert(self, p):
        if p:
            print "OK"
        else:
            print "Fail!"

    def test_heapify(self):
        # CLRS Figure 6.2
        l = [16, 4, 10, 14, 7, 9, 3, 2, 8, 1]
        heapify(l, 1, MAX_HEAP)
        print l
        self.__assert(l == [16, 14, 10, 8, 7, 9, 3, 2, 4, 1])

if __name__ == "__main__":
    TestHeap().run()

运行的话，此程序输出：
Implicit binary heap by array testing
[16, 14, 10, 8, 7, 9, 3, 2, 4, 1]
OK

未完，待续
-- 
刘
https://sites.google.com/site/algoxy/home

    Reply     Reply to author     Forward  
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
liuxinyu   	
View profile   Translate to English Translated (View Original)
	 More options Sep 25, 5:39 pm
From: liuxinyu <liuxiny...@gmail.com>
Date: Sat, 25 Sep 2010 02:39:40 -0700 (PDT)
Local: Sat, Sep 25 2010 5:39 pm
Subject: Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Remove | Report this message | Find messages by this author
Hi,

继续，有了最核心的heapify，把一个无序的array，转变成implicit heap by array就非常容易了。
我们注意，由于是binary heap，所以树的每层的节点数目是：
1, 2, 4, 8, ... 2^(i-1)

对任何叶子节点，做heapify不会有任何作用个，所以我们可以忽略全部叶子节点。
为此，针对长度为n的数组，我们只要从第2/n个元素，到第1个元素，依次做一遍heapify就可以了：

# build min heap by default
def build_heap(x, less_p = MIN_HEAP):
    n = len(x)
    for i in reversed(range(n//2)):
        heapify(x, i, less_p)

现在我们来verify一下，case选用CLRS的figure 6.3：
    def test_build_heap(self):
        # CLRS Figure 6.3
        l = [4, 1, 3, 2, 16, 9, 10, 14, 8, 7]
        build_heap(l, MAX_HEAP)
        print l
        self.__assert(l == [16, 14, 10, 8, 7, 9, 3, 2, 4, 1])

运行输出：
Implicit binary heap by array testing
[16, 14, 10, 8, 7, 9, 3, 2, 4, 1]
OK
[16, 14, 10, 8, 7, 9, 3, 2, 4, 1]
OK

下面我们实现heap的另外一个重要操作delete min。也就是弹出堆顶元素。
这个操作看似简单，只要返回，并移除数组的首元素即可，但是为了弹出后保持堆的性质，必须对剩余元素做一次heapify
# default apply to min-heap
def heap_pop(x, less_p = MIN_HEAP):
    top = x.pop(0)
    if x!=[]:
        heapify(x, 0, less_p)
    return top

有了这些铺垫，就可以利用heap来实现排序了。
CLRS上的思路是，建立大顶堆，然后每次把堆顶元素交换到数组末尾。这一思路非常好。
但是，为了统一覆盖所有不同底层数据结构的各种堆，我们把堆排序策略变一下（当然效率没有CLRS上的那个快）。
1, 建立空小顶堆，将待排序元素全部放到（例如使用insert）堆上；
2，弹出堆顶元素（也就是执行一次delete min），放到结果中；
3，重复步骤2直到堆为空。

所以，结果序列中依次被放入了，最小，次小，次次小....的全部元素，从而实现了排序。
python中的heapq的测试程序中采用了类似的方法。
# default heap sort less to greater
def heap_sort(x, less_p = MIN_HEAP):
    res = []
    build_heap(x, less_p)
    while x!=[]:
        res.append(heap_pop(x, less_p))
    return res

我们看一下测试代码和结果：
    def test_heap_sort(self):
        # CLRS Figure 6.4
        l = [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]
        res = heap_sort(l)
        print res
        self.__assert(res == [1, 2, 3, 4, 7, 8, 9, 10, 14, 16])

运行结果为：
[1, 2, 3, 4, 7, 8, 9, 10, 14, 16]
OK

未完待续

-- 
刘
https://sites.google.com/site/algoxy/home

On Sep 25, 5:22 pm, liuxinyu <liuxiny...@gmail.com> wrote:

- Hide quoted text -
- Show quoted text -
> Hi,

> 今天抽出点时间。

> 我们慢慢来，先复习下算法导论（CLRS）中的binary heap。
> 导论课本中给出的binary heap实际是recursive实现的。如果大家翻看STL的heap或者python的heapq，就会发现实现上
> 略有差别。尤其是heap sort的实现。

> 正如在前面post中提到的，我们打算把各种heap统一对比来看。所以这里给出一个区别于CLRS的heap定义（广义定义）：
> 一个heap（堆）是这样一个数据结构，
> * 它有一个顶，保存着最小（大）值；
> * 它可以支持弹出堆顶元素的操作，弹出后的堆仍然保持的堆的特性，也就是堆顶元素最小（大）；
> * 它支持插入操作，插入一个新值后，仍然保持堆的特性，也就是堆顶元素最小（大）；

> 还有其他一些可选操作，如：
> * 可以把两个堆合并(merge)成一个堆，合并后，仍然保持堆的特性，也就是堆顶元素最小（大）

> 根据这个定义，我们发现可以用多种更基本的数据结构来实现堆，只要它满足上述的定义即可。其中最简单直接的一种解法是树，只要保持树根永远最小（大）就
> 可以了。
> 注意，这里我没有说一定是二叉树，凡是用二叉树实现的heap，称之为binary heap。

> CLRS中第6章给出的binary heap，实际上严格讲应该叫做implicit binary heap by array，也就是用
> array实现的隐式heap。
> 其本质思想是把array的index对应到二叉树的节点上的一个map，这个map用c++和python这样以0作为数组起始index的语言来
> 说，可以定义如下（这里用python)
> def parent(i):
>     return (i+1)//2-1

> def left(i):
>     return  2*i+1

> def right(i):
>     return 2*(i+1)
> 注意，这里的定义和CLRS的有区别，原因是CLRS的数组从1开始。//表示取整除法。当然，在实际代码中，为了增加速度，可以使用移位运算符>>或
> <<，如C++/STL和python
> 的heapq都是如此。

> 这一map定义了如何从第i个数组元素，找到其对应的二叉树上的父节点，左子节点，和右子节点。
> 举个例子，数组[16, 4, 10, 14, 7, 9, 3, 2, 8, 1]对应了二叉树：
> ((((2 14 8)) 4 ((1 7 .))) 16 (9 10 3)) 这里的二叉树使用in-order来表示。

> 为了generic，我抽象了两个比较运算：
> MIN_HEAP = lambda a, b: a < b
> MAX_HEAP = lambda a, b: a > b
> 也就是小于运算用于min-heap(小顶堆)，大于运算用于max-heap（大顶堆）

> 有了这个隐式数组表示，就可以实现最核心的heapify函数了，这个算法用递归的表达非常直观：
> 如果数组中第i个元素对应到某个子树的树根节点，那么这个子树如果满足heap的性质，则树根节点必须子树中所有元素中最小（大）的。
> 为此：
> 平凡情况：若此节点是一个叶子节点，退出；
> 一般情况：检查此节点的左右子节点，找出最小（大）的一个，和此节点交换，然后递归heapify交换后的子树。

> CLRS上给出的MAX-HEAPIFY算法就是这个递归算法的 pseudo code 的描述，可以把它改为纯imperative实现，消除这个
> 递归，如下：

> def heapify(x, i):
>     n = len(x)
>     while True:
>         l = left(i)
>         r = right(i)
>         largest = i
>         if l < n and x[l] < x[i]:
>             largest = l
>         if r < n and x[r] < x[largest]:
>             largest = r
>         if largest != i:
>             (x[i], x[largest])=(x[largest], x[i])
>             i  = largest
>         else:
>             break

> 注意，这里用的是小顶堆。为了通用，我们可以引入less_p，就是把用来判断大小的关系运算抽象出来：
> # min-heapify by default
> def heapify(x, i, less_p = MIN_HEAP):
>     n = len(x)
>     while True:
>         l = left(i)
>         r = right(i)
>         largest = i
>         if l < n and less_p(x[l], x[i]):
>             largest = l
>         if r < n and less_p(x[r], x[largest]):
>             largest = r
>         if largest != i:
>             (x[i], x[largest])=(x[largest], x[i])
>             i  = largest
>         else:
>             break

> 为了验证其正确性，我们可以使用CLRS的figure 6.2来测试下：
> class TestHeap:
>     def __init__(self):
>         print "Implicit binary heap by array testing"

>     def run(self):
>         self.test_heapify()

>     def __assert(self, p):
>         if p:
>             print "OK"
>         else:
>             print "Fail!"

>     def test_heapify(self):
>         # CLRS Figure 6.2
>         l = [16, 4, 10, 14, 7, 9, 3, 2, 8, 1]
>         heapify(l, 1, MAX_HEAP)
>         print l
>         self.__assert(l == [16, 14, 10, 8, 7, 9, 3, 2, 4, 1])

> if __name__ == "__main__":
>     TestHeap().run()

> 运行的话，此程序输出：
> Implicit binary heap by array testing
> [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]
> OK

> 未完，待续
> --
> 刘https://sites.google.com/site/algoxy/home


    Reply     Reply to author     Forward  
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
liuxinyu   	
View profile   Translate to English Translated (View Original)
	 More options Sep 25, 5:52 pm
From: liuxinyu <liuxiny...@gmail.com>
Date: Sat, 25 Sep 2010 02:52:29 -0700 (PDT)
Local: Sat, Sep 25 2010 5:52 pm
Subject: Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Remove | Report this message | Find messages by this author
Hi,

针对排序这种情况，我们当然可以利用build_heap，一次性把堆建好，可是针对实际中的更多情况。
一个堆通常允许添加新的元素，或者改变其中某些元素的值。

我们知道堆是实现priority queue的一个手段直接，一个带优先级的队列的应用场景包括作业调度。
我们可以把一个优先级很高的作业插入队列中，或者提高一个作业的优先级，是的下次schedule的时候，
某个作业有限得到执行的机会。

为此我们需要实现堆的插入操作：
# insert a key to min-heap by default
def heap_insert(x, key, less_p = MIN_HEAP):
    i = len(x)
    x.append(key)
    heap_fix(x, i, less_p)

def heap_fix(x, i, less_p = MIN_HEAP):
    while i>0 and less_p(x[i],x[parent(i)]):
        (x[parent(i)], x[i]) = (x[i], x[parent(i)])
        i = parent(i)

采用array实现堆时，这个算法的思路是，把新的元素加到最尾，于是其变为一个叶子节点。
然后我们自底向上（从叶子向根）回溯，发现其不满足小顶堆的性质，就交换其父节点和当前节点。
这一过程很形象的像是一个物体从水底浮上来的过程。

注意，这个思路和CLRS的略有不同（本质是一致的），CLRS插入一个负无穷节点，然后调用increase key来做。
其实increase key,对于小顶堆来说是decrease key，它可以用类似的向上浮动的算法实现如下：
def heap_decrease_key(x, i, key, less_p = MIN_HEAP):
    if less_p(key, x[i]):
        x[i] = key
        heap_fix(x, i, less_p)

最后，我给一个利用堆求top k最大元素的算法：
def top_k(x, k, less_p = MIN_HEAP):
    build_heap(x, less_p)
    return [heap_pop(x, less_p) for i in range(min(k, len(x)))]

imperative的先到这里，我后面会给出纯FP的heap，包括
binomial heap, leftist heap, 和pairing heap。
不过时间不保证，各位可能要多等一阵。

-- 
刘
https://sites.google.com/site/algoxy/home

On Sep 25, 5:39 pm, liuxinyu <liuxiny...@gmail.com> wrote:

- Hide quoted text -
- Show quoted text -
> Hi,

> 继续，有了最核心的heapify，把一个无序的array，转变成implicit heap by array就非常容易了。
> 我们注意，由于是binary heap，所以树的每层的节点数目是：
> 1, 2, 4, 8, ... 2^(i-1)

> 对任何叶子节点，做heapify不会有任何作用个，所以我们可以忽略全部叶子节点。
> 为此，针对长度为n的数组，我们只要从第2/n个元素，到第1个元素，依次做一遍heapify就可以了：

> # build min heap by default
> def build_heap(x, less_p = MIN_HEAP):
>     n = len(x)
>     for i in reversed(range(n//2)):
>         heapify(x, i, less_p)

> 现在我们来verify一下，case选用CLRS的figure 6.3：
>     def test_build_heap(self):
>         # CLRS Figure 6.3
>         l = [4, 1, 3, 2, 16, 9, 10, 14, 8, 7]
>         build_heap(l, MAX_HEAP)
>         print l
>         self.__assert(l == [16, 14, 10, 8, 7, 9, 3, 2, 4, 1])

> 运行输出：
> Implicit binary heap by array testing
> [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]
> OK
> [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]
> OK

> 下面我们实现heap的另外一个重要操作delete min。也就是弹出堆顶元素。
> 这个操作看似简单，只要返回，并移除数组的首元素即可，但是为了弹出后保持堆的性质，必须对剩余元素做一次heapify
> # default apply to min-heap
> def heap_pop(x, less_p = MIN_HEAP):
>     top = x.pop(0)
>     if x!=[]:
>         heapify(x, 0, less_p)
>     return top

> 有了这些铺垫，就可以利用heap来实现排序了。
> CLRS上的思路是，建立大顶堆，然后每次把堆顶元素交换到数组末尾。这一思路非常好。
> 但是，为了统一覆盖所有不同底层数据结构的各种堆，我们把堆排序策略变一下（当然效率没有CLRS上的那个快）。
> 1, 建立空小顶堆，将待排序元素全部放到（例如使用insert）堆上；
> 2，弹出堆顶元素（也就是执行一次delete min），放到结果中；
> 3，重复步骤2直到堆为空。

> 所以，结果序列中依次被放入了，最小，次小，次次小....的全部元素，从而实现了排序。
> python中的heapq的测试程序中采用了类似的方法。
> # default heap sort less to greater
> def heap_sort(x, less_p = MIN_HEAP):
>     res = []
>     build_heap(x, less_p)
>     while x!=[]:
>         res.append(heap_pop(x, less_p))
>     return res

> 我们看一下测试代码和结果：
>     def test_heap_sort(self):
>         # CLRS Figure 6.4
>         l = [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]
>         res = heap_sort(l)
>         print res
>         self.__assert(res == [1, 2, 3, 4, 7, 8, 9, 10, 14, 16])

> 运行结果为：
> [1, 2, 3, 4, 7, 8, 9, 10, 14, 16]
> OK

> 未完待续


    Reply     Reply to author     Forward  
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
liuxinyu   	
View profile   Translate to English Translated (View Original)
	 More options Sep 26, 4:20 pm
From: liuxinyu <liuxiny...@gmail.com>
Date: Sun, 26 Sep 2010 01:20:35 -0700 (PDT)
Local: Sun, Sep 26 2010 4:20 pm
Subject: Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Remove | Report this message | Find messages by this author
Hi,

今天我们进入Leftist Heap的世界。
翻看一下Rossetta code中heap sort的各种语言实现：
http://rosettacode.org/wiki/Sorting_algorithms/Heapsort
除了Haskell外，全部其他语言都是用了Binary Heap，可见其影响之大。
R.W. Floyd给出的这个binary heap的sort方法，将性能提高了25%。
http://en.wikipedia.org/wiki/Heapsort

正因如此，在实现一个真正的FP的heap时，在列表的随机访问的复杂度退化成O(N)时，就不得不使得我们思考，是否存在其他数据结构？
基于我昨天给出的广义heap定义，不使用implicit heap by array这个思路，树就是我们非常自然想到的一个底层数据结构。

Leftist Heap是使用Leftist tree来实现的heap. Leftist tree由C. A. Crane在1972年给出，
Knuth在其TAOCP中有所介绍。
我这里先给出一些网络上能找到的资料：
WIKI:
http://en.wikipedia.org/wiki/Leftist_tree
on line book:
http://www.brpreiss.com/books/opus4/html/page362.html#SECTION00123000...

未完待续

-- 
刘
https://sites.google.com/site/algoxy/home

    Reply     Reply to author     Forward  
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
liuxinyu   	
View profile   Translate to English Translated (View Original)
	 More options Sep 28, 5:10 pm
From: liuxinyu <liuxiny...@gmail.com>
Date: Tue, 28 Sep 2010 02:10:33 -0700 (PDT)
Local: Tues, Sep 28 2010 5:10 pm
Subject: Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Remove | Report this message | Find messages by this author
Hi,

今天继续Leftist Heap

既然我们可以用array来implicit表示二叉树，从而实现Heap，那么可不可以直接用显示的（explicit）的二叉树来实现Heap
呢？
答案是可以的，但是有几个难题必须得解决。

第一个难题是heap pop，也就是delete Min操作。考虑下面的显示二叉树：

(left value right)

其中value小于所有left中节点上的值，且value小于所有right中节点上的值。

那么heap pop后，value被弹出去了，剩下了两个子树left和right，我们需要merge left和right从而得到一个新的二叉
树，且其根节点的值为最小值，以满足heap的性质。

如何merge left和right呢？我们知道left和right也是用显示二叉树表示的heap，有两个平凡解可以立刻的出来：
merge NIL right = right
merge left NIL = left
难点是，如果left和right都不为空怎么merge。
由于left和right都满足heap的性质，故而left和right的顶部的值分别是各自的最小值。我们只要比较这两个值，找一个更小的作为新的
顶部，然后把较大值所在的树的merge到一个子树中即可。举个例子，假设left = (a x b); right = (a' y b')，其中
a, a', b, b'分别为子树，如果x<y我们可以有两个备选方案：
方案一：
  (merge(a, right), x b)
方案二：
  (a, x (merge b, right))
两个方案都可以，为了简单，我们一律在右侧子树上做进一步的merge。但是这个简单方案有个缺点：就是树可能变得极不平衡。如果树非常容易退化成瘸腿
的链表，
那么复杂度就从O(lg N)退化成O(N)了。

为了防止这种情况，必须想出一个保护树平衡的办法，Leftist tree提出了这样的一个思路。首先我们需要为每个节点定义一个rank，rank
的含义是，这个节点到最近的一个叶子节点的距离。例如树：
((6, 5, .), 4, 8)
其中根节点4到最近的叶子节点8的的距离是2（我们把NIL定义为叶子节点）。节点6和8都是叶子节点，所以其rank是1，节点5虽然有左侧子树，但
是其右侧为NIL，所以其道最近的叶子节点的距离仍然是1，故而rank为1.

有了rank，就可以定义这样的一个策略:
1: 每次我们都merge到右侧;得到一个新的右侧子树，其rank为RR
2：比较左右子树的rank, 若左侧子树的rank为RL，比较RL, RR，若RL<RR，则交换左右子树。

为什么这个策略能够使得树逐渐平衡呢？这是因为我们一般把新的树merge到右侧，于是右侧的rank逐渐增长，当期超过左侧的rank时，再向右侧增
加就不平衡了，于是我们交换左右。这样长期下来，就能够保证左右平衡。

现在我们来看看Haskell下这个merge是怎么实现的。

首先我们给出Leftist Heap的定义：
data LHeap a = E -- Empty
             | Node Int a (LHeap a) (LHeap a) -- rank, element, left,
right
               deriving (Eq, Show)

然后我们定义rank函数如下：
rank::LHeap a -> Int
rank E = 0
rank (Node r _ _ _) = r

接下来就可以定义merge了：
merge::(Ord a)=>LHeap a -> LHeap a -> LHeap a
merge E h = h
merge h E = h
merge h1@(Node _ x l r) h2@(Node _ y l' r') =
    if x < y then makeNode x l (merge r h2)
    else makeNode y l' (merge h1 r')

其中makeNode比较左右的rank,并可能交换左右子树：
makeNode::a -> LHeap a -> LHeap a -> LHeap a
makeNode x a b = if rank a < rank b then Node (rank a + 1) x b a
                 else Node (rank b + 1) x a b

略微解释下为何rank要+1，
若左右子树left, right中较小的rank为R，则新树(left, x, right)的rank，由于在顶部增加了一个x，故而其rank
必然为R+1。

有了merge，deleteMin就可以轻易实现了：
deleteMin :: (Ord a) => LHeap a -> LHeap a
deleteMin (Node _ _ l r) = merge l r

接下来的难题由于有了merge迎刃而解。
难题二，在implicity heap by array的insert中，我们把新节点加入到叶子，然后逐渐向上比较，浮动。但是显示二叉树不遍历
的话
就无法找出最后一个叶子的位置。解决方法是用merge：

insert::(Ord a)=> LHeap a -> a -> LHeap a
insert h x = merge (Node 1 x E E) h

当向heap中增加一个新值时，我们首先利用这个新值，建立一个只有一个节点的树，然后把它merge到heap中。

为了方便，我定义了一个fromList函数，可以把一个list变成heap:
fromList :: (Ord a) => [a] -> LHeap a
fromList xs = foldl insert E xs

原理就是一次把list中的每个元素加入到heap中。

接下来就可以实现heap sort了。
heapSort :: (Ord a) => [a] -> [a]
heapSort = hsort . fromList where
    hsort E = []
    hsort h = (findMin h):(hsort $ deleteMin h)

我们把带排序序列变成heap，然后每次弹出最小的到结果即可。

测试一下：
testHeapSort = heapSort [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]

输出：
*LeftistHeap> testHeapSort
[1,2,3,4,7,8,9,10,14,16]

我估计我是头一个以显示二叉树实现Heap的角度介绍Leftist Heap的。有些猜测（例如平衡策略）可能想当然了。欢迎大家指正。

先到这里，后面我介绍binomial heap。
-- 
刘
https://sites.google.com/site/algoxy/home

On Sep 26, 4:20 pm, liuxinyu <liuxiny...@gmail.com> wrote:

- Hide quoted text -
- Show quoted text -
> Hi,

> 今天我们进入Leftist Heap的世界。
> 翻看一下Rossetta code中heap sort的各种语言实现：http://rosettacode.org/wiki/Sorting_algorithms/Heapsort
> 除了Haskell外，全部其他语言都是用了Binary Heap，可见其影响之大。
> R.W. Floyd给出的这个binary heap的sort方法，将性能提高了25%。http://en.wikipedia.org/wiki/Heapsort

> 正因如此，在实现一个真正的FP的heap时，在列表的随机访问的复杂度退化成O(N)时，就不得不使得我们思考，是否存在其他数据结构？
> 基于我昨天给出的广义heap定义，不使用implicit heap by array这个思路，树就是我们非常自然想到的一个底层数据结构。

> Leftist Heap是使用Leftist tree来实现的heap. Leftist tree由C. A. Crane在1972年给出，
> Knuth在其TAOCP中有所介绍。
> 我这里先给出一些网络上能找到的资料：
> WIKI:http://en.wikipedia.org/wiki/Leftist_tree
> on line book:http://www.brpreiss.com/books/opus4/html/page362.html#SECTION00123000...

> 未完待续

> --
> 刘https://sites.google.com/site/algoxy/home


    Reply     Reply to author     Forward  
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
  	
View profile   Translate to English Translated (View Original)
	 More options Sep 28, 5:12 pm
From: 机械唯物主义 : linjunhalida <linjunhal...@gmail.com>
Date: Tue, 28 Sep 2010 17:12:54 +0800
Local: Tues, Sep 28 2010 5:12 pm
Subject: Re: [TL] Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Report this message | Find messages by this author

有没有haskell-cn群组呢? 记得有erlang群组.
感觉有很多有意思的问题可以以haskell的方式来交流.

    Reply     Reply to author     Forward       
Report spam
Reporting spam
Message reported
    Rate this post: Text for clearing space
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
liuxinyu   	
View profile   Translate to English Translated (View Original)
	 More options Sep 29, 6:06 pm
From: liuxinyu <liuxiny...@gmail.com>
Date: Wed, 29 Sep 2010 03:06:35 -0700 (PDT)
Local: Wed, Sep 29 2010 6:06 pm
Subject: Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Remove | Report this message | Find messages by this author
刚才google搜了下：
http://groups.google.com/group/haskellcn

我没用过，不知道其质量如何。

On Sep 28, 5:12 pm, 机械唯物主义 : linjunhalida <linjunhal...@gmail.com>
wrote:

- Hide quoted text -
- Show quoted text -
> 有没有haskell-cn群组呢? 记得有erlang群组.
> 感觉有很多有意思的问题可以以haskell的方式来交流.


    Reply     Reply to author     Forward  
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
liuxinyu   	
View profile   Translate to English Translated (View Original)
	 More options Sep 30, 9:41 am
From: liuxinyu <liuxiny...@gmail.com>
Date: Wed, 29 Sep 2010 18:41:44 -0700 (PDT)
Local: Thurs, Sep 30 2010 9:41 am
Subject: Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Remove | Report this message | Find messages by this author
Hi,

今天继续介绍其他Heap。

一个自然的问题是，既然已经可以用数组实现隐式的binary heap，也可以用显示的特殊二叉树Leftist tree实现binary
heap。并且这两种heap sort的算法复杂度都达到了O(N*lg N)，为啥还要搞其他heap？

这是因为heap的用途，不仅仅在于heap sort，heap sort以及寻找N-largest(smallest)仅仅以heap的应用之
一。heap可以用来实现priority queue，更大的应用在于graph中。所以我们希望能够尽量提高一些heap常见操作的性能

我们来观察一下binary heap基本操作中一些算法复杂度：

merge:
  implicit array: O(N)
  leftist heap: O(lg N)

insert:
  implicit array: O(lg N)
  leftist heap: O(lg N)

min:
  implicit array: O(1)
  leftist heap: O(1)

delete min(pop)
  implicit array: O(lg N)
  leftist heap: O(lg N)

为了，很多人进行了多年的努力，目前最好的结果是，除了delete min是O(lg N)外，其余操作都可以达到O(1)。这是一个巨大的成就。
因此了解这个成就背后的故事，是个很有意义的事情。

先到这里，回头再写。

-- 
刘
https://sites.google.com/site/algoxy/home

On Sep 28, 5:10 pm, liuxinyu <liuxiny...@gmail.com> wrote:

- Hide quoted text -
- Show quoted text -
> Hi,

> 今天继续Leftist Heap

> 既然我们可以用array来implicit表示二叉树，从而实现Heap，那么可不可以直接用显示的（explicit）的二叉树来实现Heap
> 呢？
> 答案是可以的，但是有几个难题必须得解决。

> 第一个难题是heap pop，也就是delete Min操作。考虑下面的显示二叉树：

> (left value right)

> 其中value小于所有left中节点上的值，且value小于所有right中节点上的值。

> 那么heap pop后，value被弹出去了，剩下了两个子树left和right，我们需要merge left和right从而得到一个新的二叉
> 树，且其根节点的值为最小值，以满足heap的性质。

> 如何merge left和right呢？我们知道left和right也是用显示二叉树表示的heap，有两个平凡解可以立刻的出来：
> merge NIL right = right
> merge left NIL = left
> 难点是，如果left和right都不为空怎么merge。
> 由于left和right都满足heap的性质，故而left和right的顶部的值分别是各自的最小值。我们只要比较这两个值，找一个更小的作为新的
> 顶部，然后把较大值所在的树的merge到一个子树中即可。举个例子，假设left = (a x b); right = (a' y b')，其中
> a, a', b, b'分别为子树，如果x<y我们可以有两个备选方案：
> 方案一：
>   (merge(a, right), x b)
> 方案二：
>   (a, x (merge b, right))
> 两个方案都可以，为了简单，我们一律在右侧子树上做进一步的merge。但是这个简单方案有个缺点：就是树可能变得极不平衡。如果树非常容易退化成瘸腿
> 的链表，
> 那么复杂度就从O(lg N)退化成O(N)了。

> 为了防止这种情况，必须想出一个保护树平衡的办法，Leftist tree提出了这样的一个思路。首先我们需要为每个节点定义一个rank，rank
> 的含义是，这个节点到最近的一个叶子节点的距离。例如树：
> ((6, 5, .), 4, 8)
> 其中根节点4到最近的叶子节点8的的距离是2（我们把NIL定义为叶子节点）。节点6和8都是叶子节点，所以其rank是1，节点5虽然有左侧子树，但
> 是其右侧为NIL，所以其道最近的叶子节点的距离仍然是1，故而rank为1.

> 有了rank，就可以定义这样的一个策略:
> 1: 每次我们都merge到右侧;得到一个新的右侧子树，其rank为RR
> 2：比较左右子树的rank, 若左侧子树的rank为RL，比较RL, RR，若RL<RR，则交换左右子树。

> 为什么这个策略能够使得树逐渐平衡呢？这是因为我们一般把新的树merge到右侧，于是右侧的rank逐渐增长，当期超过左侧的rank时，再向右侧增
> 加就不平衡了，于是我们交换左右。这样长期下来，就能够保证左右平衡。

> 现在我们来看看Haskell下这个merge是怎么实现的。

> 首先我们给出Leftist Heap的定义：
> data LHeap a = E -- Empty
>              | Node Int a (LHeap a) (LHeap a) -- rank, element, left,
> right
>                deriving (Eq, Show)

> 然后我们定义rank函数如下：
> rank::LHeap a -> Int
> rank E = 0
> rank (Node r _ _ _) = r

> 接下来就可以定义merge了：
> merge::(Ord a)=>LHeap a -> LHeap a -> LHeap a
> merge E h = h
> merge h E = h
> merge h1@(Node _ x l r) h2@(Node _ y l' r') =
>     if x < y then makeNode x l (merge r h2)
>     else makeNode y l' (merge h1 r')

> 其中makeNode比较左右的rank,并可能交换左右子树：
> makeNode::a -> LHeap a -> LHeap a -> LHeap a
> makeNode x a b = if rank a < rank b then Node (rank a + 1) x b a
>                  else Node (rank b + 1) x a b

> 略微解释下为何rank要+1，
> 若左右子树left, right中较小的rank为R，则新树(left, x, right)的rank，由于在顶部增加了一个x，故而其rank
> 必然为R+1。

> 有了merge，deleteMin就可以轻易实现了：
> deleteMin :: (Ord a) => LHeap a -> LHeap a
> deleteMin (Node _ _ l r) = merge l r

> 接下来的难题由于有了merge迎刃而解。
> 难题二，在implicity heap by array的insert中，我们把新节点加入到叶子，然后逐渐向上比较，浮动。但是显示二叉树不遍历
> 的话
> 就无法找出最后一个叶子的位置。解决方法是用merge：

> insert::(Ord a)=> LHeap a -> a -> LHeap a
> insert h x = merge (Node 1 x E E) h

> 当向heap中增加一个新值时，我们首先利用这个新值，建立一个只有一个节点的树，然后把它merge到heap中。

> 为了方便，我定义了一个fromList函数，可以把一个list变成heap:
> fromList :: (Ord a) => [a] -> LHeap a
> fromList xs = foldl insert E xs

> 原理就是一次把list中的每个元素加入到heap中。

> 接下来就可以实现heap sort了。
> heapSort :: (Ord a) => [a] -> [a]
> heapSort = hsort . fromList where
>     hsort E = []
>     hsort h = (findMin h):(hsort $ deleteMin h)

> 我们把带排序序列变成heap，然后每次弹出最小的到结果即可。

> 测试一下：
> testHeapSort = heapSort [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]

> 输出：
> *LeftistHeap> testHeapSort
> [1,2,3,4,7,8,9,10,14,16]

> 我估计我是头一个以显示二叉树实现Heap的角度介绍Leftist Heap的。有些猜测（例如平衡策略）可能想当然了。欢迎大家指正。

> 先到这里，后面我介绍binomial heap。
> --
> 刘https://sites.google.com/site/algoxy/home


    Reply     Reply to author     Forward  
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
liuxinyu   	
View profile   Translate to English Translated (View Original)
	 More options Sep 30, 10:36 am
From: liuxinyu <liuxiny...@gmail.com>
Date: Wed, 29 Sep 2010 19:36:38 -0700 (PDT)
Local: Thurs, Sep 30 2010 10:36 am
Subject: Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Remove | Report this message | Find messages by this author
Hi,

刚才仔细寻找了一下Leftist Tree的软肋。

几乎和Quick Sort一样，面对有序序列，Leftist Tree迅速退化成了瘸腿链表。例如：

*LeftistHeap> fromList [16, 10, 14, 8, 9, 7, 2, 3, 1, 4]
Node 2 1 (Node 2 2 (Node 1 7 (Node 2 8 (Node 2 10 (Node 1 16 E E)
(Node 1 14 E E)) (Node 1 9 E E)) E) (Node 1 3 E E)) (Node 1 4 E E)

看起来很平衡

*LeftistHeap> fromList [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]
输出：
Node 1 1 (Node 2 2 (Node 1 3 (Node 2 7 (Node 1 8 (Node 1 10 (Node 1 14
(Node 1 16 E E) E) E) E) (Node 1 9 E E)) E) (Node 1 4 E E)) E) E)
(Node 1 3 E E)) (Node 1 4 E E)
结果已经非常接近瘸腿链表了

再看极端情况：

*LeftistHeap> fromList [1..10]
Node 3 1 (Node 2 3 (Node 1 4 E E) (Node 1 5 E E)) (Node 2 2 (Node 2 7
(Node 1 8 E E) (Node 1 9 E E)) (Node 1 6 (Node 1 10 E E) E))

完全退化成链表了。

-- 
刘
https://sites.google.com/site/algoxy/home

    Reply     Reply to author     Forward  
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
liuxinyu   	
View profile   Translate to English Translated (View Original)
	 More options Sep 30, 3:40 pm
From: liuxinyu <liuxiny...@gmail.com>
Date: Thu, 30 Sep 2010 00:40:39 -0700 (PDT)
Local: Thurs, Sep 30 2010 3:40 pm
Subject: Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Remove | Report this message | Find messages by this author
Hi,

开始在Algoxy上写了。
https://sites.google.com/site/algoxy/bheap

源代码在GPL下开放。文章在FDL下开放。

On Sep 30, 10:36 am, liuxinyu <liuxiny...@gmail.com> wrote:

- Hide quoted text -
- Show quoted text -
> Hi,

> 刚才仔细寻找了一下Leftist Tree的软肋。

> 几乎和Quick Sort一样，面对有序序列，Leftist Tree迅速退化成了瘸腿链表。例如：

> *LeftistHeap> fromList [16, 10, 14, 8, 9, 7, 2, 3, 1, 4]
> Node 2 1 (Node 2 2 (Node 1 7 (Node 2 8 (Node 2 10 (Node 1 16 E E)
> (Node 1 14 E E)) (Node 1 9 E E)) E) (Node 1 3 E E)) (Node 1 4 E E)

> 看起来很平衡

> *LeftistHeap> fromList [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]
> 输出：
> Node 1 1 (Node 2 2 (Node 1 3 (Node 2 7 (Node 1 8 (Node 1 10 (Node 1 14
> (Node 1 16 E E) E) E) E) (Node 1 9 E E)) E) (Node 1 4 E E)) E) E)
> (Node 1 3 E E)) (Node 1 4 E E)
> 结果已经非常接近瘸腿链表了

> 再看极端情况：

> *LeftistHeap> fromList [1..10]
> Node 3 1 (Node 2 3 (Node 1 4 E E) (Node 1 5 E E)) (Node 2 2 (Node 2 7
> (Node 1 8 E E) (Node 1 9 E E)) (Node 1 6 (Node 1 10 E E) E))

> 完全退化成链表了。

> --
> 刘https://sites.google.com/site/algoxy/home


    Reply     Reply to author     Forward  
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
liuxinyu   	
View profile   Translate to English Translated (View Original)
	 More options Oct 9, 2:13 pm
From: liuxinyu <liuxiny...@gmail.com>
Date: Fri, 8 Oct 2010 23:13:26 -0700 (PDT)
Local: Sat, Oct 9 2010 2:13 pm
Subject: Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Remove | Report this message | Find messages by this author
Hi,

今天介绍Binomial Heap，翻译成中文是"二项式堆"。
在《算法导论》的第19章，有对Binomial Heap的介绍。这一章的最难点就是把两个Binomial Heap中的Binomail
Tree按照类似 merge sort的算法，
链接成一个link list，然后进行union操作，里面涉及4个复杂的case。

在Chris Okasaki的《Purely Functional data structures》中给出了用纯FP实现Binomial
heap的思路，对比CLRS中的imperative思路，这个
方法特别的简洁。

首先介绍Binomial Heap的概念：

Binomial Heap看起来比Leftist Heap和Implicit Binary heap by array都复杂，然而他却在
merge操作上非常占有优势，binary heap为了维持
Heap property, 通常merge的复杂度达到O(N)，而Binomial Heap可以有O(lg N)。

之所以叫二项式堆，是因为他和二项式定理的紧密联系，我们回忆一下著名的杨辉三角：
      1
     1 1
    1 2 1
   1 3 3 1
  1 4 6 4 1
  ...

Binomial Heap是由一些列Binomail Tree组成的，Binomial Tree的定义是递归的，非常有趣：

一个Rank为N的Binomail Tree，是由两个Rank为N-1的Binomail Tree组成的，组成方法是把root值较小的一个作为
另一个tree的第一个子节点；
Rank为0的Binomail tree只有一个节点。

有了这个递归定义，就可以列出rank为0,1,2,...的binomail tree的形状了：

x, (x, x), (x, (x, x), x), (x, (x, (x, x), x), (x, x), x), ...

如果看这些x和括号不爽，可以参考CLRS的图19.2(b)或者http://en.wikipedia.org/wiki/
Binomial_heap中的图。

我们看binomail tree中任何一层的节点数恰好符合杨辉三角形。例如rank 为3的tree，root只有1个节点，第二层有3个节点，第
3层有3个节点，第4层有1个节点。
再隐身一步，任何rank为r的binomail tree，由于符合二项式定理的展开项，必然有2^r个节点。

一个Binomail Heap，是由若干Binomail tree，组成的列表，其中任何一个rank的tree最多只有一个。
这个有趣的定义，会引出一个有趣的结论：含有N个节点的Binomail Heap，如果把N表示成二进制形式a0,a1,a2, ... am，
则若ai为0，则没有rank为2^i的tree，若为1，则有。

例如含有5个元素的Binomial Heap，N=5,写成二进制是（LSB)101（MSB）则其含有2个Binomial tree，一个
rank为0，另一个rank为2

先到这里，待续
-- 
刘
https://sites.google.com/site/algoxy

On Sep 30, 9:41 am, liuxinyu <liuxiny...@gmail.com> wrote:

- Hide quoted text -
- Show quoted text -
> Hi,

> 今天继续介绍其他Heap。

> 一个自然的问题是，既然已经可以用数组实现隐式的binary heap，也可以用显示的特殊二叉树Leftist tree实现binary
> heap。并且这两种heap sort的算法复杂度都达到了O(N*lg N)，为啥还要搞其他heap？

> 这是因为heap的用途，不仅仅在于heap sort，heap sort以及寻找N-largest(smallest)仅仅以heap的应用之
> 一。heap可以用来实现priority queue，更大的应用在于graph中。所以我们希望能够尽量提高一些heap常见操作的性能

> 我们来观察一下binary heap基本操作中一些算法复杂度：

> merge:
>   implicit array: O(N)
>   leftist heap: O(lg N)

> insert:
>   implicit array: O(lg N)
>   leftist heap: O(lg N)

> min:
>   implicit array: O(1)
>   leftist heap: O(1)

> delete min(pop)
>   implicit array: O(lg N)
>   leftist heap: O(lg N)

> 为了，很多人进行了多年的努力，目前最好的结果是，除了delete min是O(lg N)外，其余操作都可以达到O(1)。这是一个巨大的成就。
> 因此了解这个成就背后的故事，是个很有意义的事情。

> 先到这里，回头再写。

> --
> 刘https://sites.google.com/site/algoxy/home


    Reply     Reply to author     Forward  
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
liuxinyu   	
View profile   Translate to English Translated (View Original)
	 More options Oct 9, 3:06 pm
From: liuxinyu <liuxiny...@gmail.com>
Date: Sat, 9 Oct 2010 00:06:54 -0700 (PDT)
Local: Sat, Oct 9 2010 3:06 pm
Subject: Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Remove | Report this message | Find messages by this author
Hi,

现在进入代码时间：

针对Binomail Tree的定义，我们给出其Haskell的定义代码：
data BiTree a = Node { rank :: Int
                     , root :: a
                     , children :: [BiTree a]} deriving (Eq, Show)

一个Binomail Tree包含3个部分，一个是rank，一个是root上的值（可比较），另一个是其子树列表。
并且规定，一个Binomail tree的root上的值，是所有元素中的最小（大）值。

而Binomail Heap则仅仅是Binomail Tree的一个列表：
type BiHeap a = [BiTree a]

这里有2个隐式限制条件：
1， 这个列表中的tree的rank单调增
2, 任何rank只最多出现一次

如果标记rank为k的Binomial Tree为B_{k}，则递归定义中将两个B_{k}组成一个B_{k+1}的描述可用下面代码来表示：
-- Link 2 trees with SAME rank R to a new tree of rank R+1
link :: (Ord a) => BiTree a -> BiTree a -> BiTree a
link t1@(Node r x c1) t2@(Node _ y c2) =
    if x<y then Node (r+1) x (t2:c1)
    else Node (r+1) y (t1:c2)

我们比较两个树的根节点元素的大小，将较小的一个作为新的根，然后将较大的一个作为第一个儿子，并且将rank增加1.

有了link，并且由于Binmial Heap是rank单调增的一系列tree的列表组成的这个事实，
就可以实现把一个rank不小于Binomail Heap中第一个tree的新tree插入到其中的函数：
-- Insert a Binomial tree into a Binomial heap
--  Implicit condition: the rank of tree is either lower or equal to
the first
--  element tree in the heap.
insertTree :: (Ord a) => BiHeap a -> BiTree a -> BiHeap a
insertTree [] t = [t]
insertTree ts@(t':ts') t = if rank t < rank t' then t:ts
                           else insertTree ts' (link t t')

方法很简单，先判断，待插入的树的rank是否小于heap中的第一个tree，如果小，则直接添加到列表开头。
否则说明两个rank相等，我们用link生成一个rank增加1的新tree，然后递归插入到剩余列表中。
注意这个link出的新tree，依然满足rank < or =的隐式限制条件。这是由于link只能将rank增1，而列表中tree的rank都
是非负单调增的整数。

有了这个辅助函数insert就非常方便实现了：
insert :: (Ord a) => BiHeap a -> a -> BiHeap a
insert h x = insertTree h (Node 0 x [])

当试图把一个新值插入到heap中，我们只需要用这个新值建立一个rank为0的只有一个节点的树，然后将其插入到heap中即可。

现在来测试一下：

首先定义个辅助函数，将一个列表变成一个binomial heap。
fromList :: (Ord a) => [a] -> BiHeap a
fromList xs = foldl insert [] xs

fromList [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]将输出：
[Node 1 1 [Node 0 4 []],Node 3 2 [Node 2 8 [Node 1 14 [Node 0 16
[]],Node 0 10 []],Node 1 7 [Node 0 9 []],Node 0 3 []]]

把它画在纸上，大致如下：

(1, 4) --> (2, (8, (14, 6), 10), (7, 9), 3)

其由两个tree组成，一个rank为1，另外一个rank为3.

merge的定义非常像merge sort:
merge:: (Ord a) => BiHeap a -> BiHeap a -> BiHeap a
merge ts1 [] = ts1
merge [] ts2 = ts2
merge ts1@(t1:ts1') ts2@(t2:ts2')
    | rank t1 < rank t2 = t1:(merge ts1' ts2)
    | rank t1 > rank t2 = t2:(merge ts1 ts2')
    | otherwise = insertTree (merge ts1' ts2') (link t1 t2)

现在思考deleteMin，由于heap由一系列binomail tree组成，每个tree的根节点都是最小（大）值，但是各个tree之间的根
节点的大小并不确定。
所以我们只要把heap列表中所有tree的根节点比较一下，找出最小的一个就可以了。

接下来的问题就棘手了。假设某个heap是由如下的binomail tree组成： b0, b1, ..., bm， 并且bp的根节点最小。那么
delete min后，
bp的根节点就被拿走了，bp剩下了一堆儿子，共有p个。他们恰好也都是Binomial tree，rank分别是p-1, p-2, ...
2, 1， 0。
由于我们有O(lg N)的merge，所以一个可行的解决方案就是，把剩下的这p个儿子颠倒变成另外一个heap，然后和其余的tree merge
到一起。

根据这个思路，我们首先实现一个找到含有最小根节点的binomial tree的函数：
removeMinTree :: (Ord a) => BiHeap a -> (BiTree a, BiHeap a)
removeMinTree [t] = (t, [])
removeMinTree (t:ts) = if root t < root t' then (t, ts)
                       else (t', t:ts')
    where
      (t', ts') = removeMinTree ts

这个函数把含有最小根节点的树和剩余的其他树的列表，以一个pair返回。

有了这个辅助函数，findMin就非常容易了：
findMin :: (Ord a) => BiHeap a -> a
findMin = root . fst. removeMinTree

delete的实现就是摘除最小根节点，然后儿子倒序merge回去：
deleteMin :: (Ord a) => BiHeap a -> BiHeap a
deleteMin h = merge (reverse $ children t) ts where
    (t, ts) = removeMinTree h

这样一个binomial heap就基本完成了，作为副产品，我们测试一下heap sort，测试代码和Leftist Heap的一样：
heapSort :: (Ord a) => [a] -> [a]
heapSort = hsort . fromList where
    hsort [] = []
    hsort h = (findMin h):(hsort $ deleteMin h)

heapSort [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]

输出：
[1,2,3,4,7,8,9,10,14,16]

今天先告一段落。就到这里吧
-- 
刘
https://sites.google.com/site/algoxy

On Oct 9, 2:13 pm, liuxinyu <liuxiny...@gmail.com> wrote:

- Hide quoted text -
- Show quoted text -
> Hi,

> 今天介绍Binomial Heap，翻译成中文是"二项式堆"。
> 在《算法导论》的第19章，有对Binomial Heap的介绍。这一章的最难点就是把两个Binomial Heap中的Binomail
> Tree按照类似 merge sort的算法，
> 链接成一个link list，然后进行union操作，里面涉及4个复杂的case。

> 在Chris Okasaki的《Purely Functional data structures》中给出了用纯FP实现Binomial
> heap的思路，对比CLRS中的imperative思路，这个
> 方法特别的简洁。

> 首先介绍Binomial Heap的概念：

> Binomial Heap看起来比Leftist Heap和Implicit Binary heap by array都复杂，然而他却在
> merge操作上非常占有优势，binary heap为了维持
> Heap property, 通常merge的复杂度达到O(N)，而Binomial Heap可以有O(lg N)。

> 之所以叫二项式堆，是因为他和二项式定理的紧密联系，我们回忆一下著名的杨辉三角：
>       1
>      1 1
>     1 2 1
>    1 3 3 1
>   1 4 6 4 1
>   ...

> Binomial Heap是由一些列Binomail Tree组成的，Binomial Tree的定义是递归的，非常有趣：

> 一个Rank为N的Binomail Tree，是由两个Rank为N-1的Binomail Tree组成的，组成方法是把root值较小的一个作为
> 另一个tree的第一个子节点；
> Rank为0的Binomail tree只有一个节点。

> 有了这个递归定义，就可以列出rank为0,1,2,...的binomail tree的形状了：

> x, (x, x), (x, (x, x), x), (x, (x, (x, x), x), (x, x), x), ...

> 如果看这些x和括号不爽，可以参考CLRS的图19.2(b)或者http://en.wikipedia.org/wiki/
> Binomial_heap中的图。

> 我们看binomail tree中任何一层的节点数恰好符合杨辉三角形。例如rank 为3的tree，root只有1个节点，第二层有3个节点，第
> 3层有3个节点，第4层有1个节点。
> 再隐身一步，任何rank为r的binomail tree，由于符合二项式定理的展开项，必然有2^r个节点。

> 一个Binomail Heap，是由若干Binomail tree，组成的列表，其中任何一个rank的tree最多只有一个。
> 这个有趣的定义，会引出一个有趣的结论：含有N个节点的Binomail Heap，如果把N表示成二进制形式a0,a1,a2, ... am，
> 则若ai为0，则没有rank为2^i的tree，若为1，则有。

> 例如含有5个元素的Binomial Heap，N=5,写成二进制是（LSB)101（MSB）则其含有2个Binomial tree，一个
> rank为0，另一个rank为2

> 先到这里，待续
> --
> 刘https://sites.google.com/site/algoxy


    Reply     Reply to author     Forward  
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
liuxinyu   	
View profile   Translate to English Translated (View Original)
	 More options Oct 11, 2:26 pm
From: liuxinyu <liuxiny...@gmail.com>
Date: Sun, 10 Oct 2010 23:26:06 -0700 (PDT)
Local: Mon, Oct 11 2010 2:26 pm
Subject: Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Remove | Report this message | Find messages by this author
Hi,

多说一句，Binary Heap还应该加上Splay Heap， Splay Heap被发现是最快的Heap之一。
过一阵我抽空介绍。

另外Binomial Heap的insert和merge看似都是O(lg N)的复杂度，但是注意这是worst-case的复杂度，而
amortized的复杂度是O(1)。

-- 
刘
https://sites.google.com/site/algoxy/home

    Reply     Reply to author     Forward  
		
		
		
You must Sign in before you can post messages.
To post a message you must first join this group.
Please update your nickname on the subscription settings page before posting.
You do not have the permission required to post.
	
		
liuxinyu   	
View profile   Translate to Translated (View Original)
	 More options Oct 19, 6:11 pm
From: liuxinyu <liuxiny...@gmail.com>
Date: Tue, 19 Oct 2010 03:11:22 -0700 (PDT)
Local: Tues, Oct 19 2010 6:11 pm
Subject: Re: Heap Sort in FP
Reply | Reply to author | Forward | Print | Individual message | Show original | Remove | Report this message | Find messages by this author
Hi,

快速说一下Splay Tree，Splay Tree的数据结构实际上就是一个排序二叉树BST。

但是BST的最大问题是平衡性，也就是说，如果插入一个基本有序的序列，生成的BST实际上是一个瘸腿树，几乎退化成了单链表。
所以O(Lg N)的很多树操作，退化成了O(N)

为了解决平衡性问题，人们给出了很多解法，其中著名的是红黑树，AVL树等等，
红黑树的FP实现我前阵给出过：
https://sites.google.com/site/algoxy/rbtree

Splay Tree提供了另外一个思路来解决平衡性问题。在所有access树节点时，我们会进行traverse，如果我们需要访问x，
但是从根节点起连续向左侧（右侧）访问很深的深度才访问到x，我们认为这棵树很可能不平衡，于是我们通过splay操作对
树进行旋转，使得x更加靠近根节点。（甚或干脆把x设置为根节点）。经过一系列splay操作后，这棵树就逐渐趋于平衡。

WIKI上有一个C的实现：
http://en.wikipedia.org/wiki/Splay_tree

在FP实现中，Okasaki给出了一个解决方案，当我们连续向左侧(右侧)访问了两个节点后，我们就做一次旋转。
首先是树的定义，和普通二叉树没有区别：
data STree a = E -- Empty
             | Node (STree a) a (STree a) -- left, element, right
               deriving (Eq, Show)

然后我们看核心函数partition，它接受2个参数，一个tree，和一个值y。该函数把树分成两部分，
一部分包含所有比y小的值全在一部分，所有大的在另一部分。在partition过程中，会进行splay操作。
-- partition the tree in two parts based on a pivot value,
--  less part contains all elements < pivot
--  bigger part contains all elements >= pivot
partition :: (Ord a) => STree a -> a -> (STree a, STree a)
partition E _ = (E, E)
partition t@(Node l x r) y
    | x < y =
        case r of
          E -> (t, E)
          Node l' x' r' ->
              if x' < y then
                  let (small, big) = partition r' y in
                  (Node (Node l x l') x' small, big)
              else
                  let (small, big) = partition l' y in
                  (Node l x small, Node big x' r')
    | otherwise =
        case l of
          E -> (E, t)
          Node l' x' r' ->
              if y < x' then
                  let (small, big) = partition l' y in
                  (small, Node l' x' (Node r' x r))
              else
                  let (small, big) = partition r' y in
                  (Node l' x' small, Node big x r)

有了partition就可以方便实现insert了：
insert :: (Ord a) => STree a -> a -> STree a
insert t x = Node small x big where (small, big) = partition t x

现在如果用splay作为底层数据结构实现Heap，我们必须解决findMin和deleteMin
由于是BST，所以我们只要不断寻找左子树就得到了min:

findMin :: STree a -> a
findMin (Node E x _) = x
findMin (Node l x _) = findMin l

delete时，我们不妨进行一下splay操作：

deleteMin :: STree a -> STree a
deleteMin (Node E x r) = r
deleteMin (Node (Node E x' r') x r) = Node r' x r
deleteMin (Node (Node l' x' r') x r) = Node (deleteMin l') x' (Node r'
x r)

现在就可以按照一般的heap来实现heap sort了：

fromList :: (Ord a) => [a] -> STree a
fromList xs = foldl insert E xs

heapSort :: (Ord a) => [a] -> [a]
heapSort = hsort . fromList where
    hsort E = []
    hsort h = (findMin h):(hsort $ deleteMin h)

我们测试下：
testHeapSort = heapSort [16, 14, 10, 8, 7, 9, 3, 2, 4, 1]

程序输出：
*SplayHeap> testHeapSort
[1,2,3,4,7,8,9,10,14,16]

我个人觉得Okasaki的方法存在pattern matching的更加简洁的解法，目前还在思考中，晚些时候我可能给出其他解法。

-- 
刘
https://sites.google.com/site/algoxy/home